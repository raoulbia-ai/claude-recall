import { LoggingService } from './logging';

export interface NLPAnalysisRequest {
  prompt: string;
  context?: string;
  existingPreferences?: Record<string, any>;
}

export interface NLPAnalysisMarker {
  type: 'ANALYZE_PREFERENCE' | 'PREFERENCE_DETECTED';
  content: string;
  metadata?: Record<string, any>;
}

export interface ExtractedPreference {
  key: string;
  value: any;
  confidence: number;
  rawText: string;
}

export class ClaudeNLPAnalyzer {
  private static readonly ANALYSIS_MARKER = 'üîç PREFERENCE_ANALYSIS:';
  private static readonly RESPONSE_MARKER = 'PREF[';
  private static readonly RESPONSE_MARKER_END = ']';

  /**
   * Generates analysis markers for Claude to understand preferences
   */
  static createAnalysisMarker(prompt: string, existingPreferences?: Record<string, any>): string {
    const preferenceContext = existingPreferences 
      ? `\nCurrent preferences: ${JSON.stringify(existingPreferences, null, 2)}`
      : '';

    return `${this.ANALYSIS_MARKER} Analyze if this expresses a preference update: "${prompt}"${preferenceContext}
If this updates a preference, include in your response: ${this.RESPONSE_MARKER}key:value${this.RESPONSE_MARKER_END}`;
  }

  /**
   * Extracts preferences from Claude's response
   */
  static extractPreferencesFromResponse(response: string): ExtractedPreference[] {
    const preferences: ExtractedPreference[] = [];
    const regex = new RegExp(`${this.RESPONSE_MARKER.replace('[', '\\[')}([^:]+):([^\\]]+)${this.RESPONSE_MARKER_END.replace(']', '\\]')}`, 'g');
    
    let match;
    while ((match = regex.exec(response)) !== null) {
      const [fullMatch, key, value] = match;
      preferences.push({
        key: key.trim(),
        value: this.parseValue(value.trim()),
        confidence: 1.0, // Claude's understanding has high confidence
        rawText: fullMatch
      });
    }

    return preferences;
  }

  /**
   * Determines if a prompt likely contains a preference
   */
  static mightContainPreference(prompt: string): boolean {
    // Use simple heuristics to avoid unnecessary analysis
    const preferenceIndicators = [
      'from now on',
      'moving forward',
      'going forward',
      'let\'s use',
      'let\'s put',
      'let\'s start',
      'should be',
      'should go',
      'belong in',
      'save in',
      'store in',
      'create in',
      'put all',
      'place all',
      'i prefer',
      'i think',
      'i want',
      'please use',
      'always',
      'default',
      'use __',
      'save .* under',
      'put .* in',
      'can we put'
    ];

    const lowerPrompt = prompt.toLowerCase();
    return preferenceIndicators.some(indicator => {
      // Some indicators are regex patterns
      if (indicator.includes('.*')) {
        const regex = new RegExp(indicator, 'i');
        return regex.test(lowerPrompt);
      }
      return lowerPrompt.includes(indicator);
    });
  }

  /**
   * Creates a clean analysis context without visible markers
   */
  static createHiddenAnalysisContext(prompt: string): string {
    // This creates an invisible analysis request that Claude will understand
    // but won't be shown to the user
    return `\n<!-- ${this.createAnalysisMarker(prompt)} -->`;
  }

  /**
   * Parses value strings into appropriate types
   */
  private static parseValue(value: string): any {
    // Remove quotes if present
    if ((value.startsWith('"') && value.endsWith('"')) || 
        (value.startsWith("'") && value.endsWith("'"))) {
      return value.slice(1, -1);
    }

    // Try to parse as boolean
    if (value.toLowerCase() === 'true') return true;
    if (value.toLowerCase() === 'false') return false;

    // Try to parse as number
    const num = Number(value);
    if (!isNaN(num)) return num;

    // Return as string
    return value;
  }

  /**
   * Maps natural language descriptions to preference keys
   */
  static inferPreferenceKey(description: string): string | null {
    const keyMappings = {
      'test': ['test_location', 'test_directory', 'test_path'],
      'tests': ['test_location', 'test_directory', 'test_path'],
      'testing': ['test_location', 'test_directory', 'test_path'],
      'code': ['code_style', 'code_format'],
      'style': ['code_style', 'format_style'],
      'language': ['language_preference', 'preferred_language'],
      'framework': ['framework_preference', 'preferred_framework'],
      'database': ['database_type', 'db_preference'],
      'naming': ['naming_convention', 'naming_style'],
      'indent': ['indentation', 'indent_style'],
      'tab': ['indentation', 'indent_style'],
      'space': ['indentation', 'indent_style']
    };

    const lowerDesc = description.toLowerCase();
    for (const [keyword, possibleKeys] of Object.entries(keyMappings)) {
      if (lowerDesc.includes(keyword)) {
        return possibleKeys[0]; // Return the first matching key
      }
    }

    return null;
  }

  /**
   * Analyzes Claude's response for implicit preference understanding
   */
  static analyzeImplicitPreferences(response: string, originalPrompt: string): ExtractedPreference[] {
    const preferences: ExtractedPreference[] = [];

    // Look for acknowledgment patterns
    const acknowledgmentPatterns = [
      /I'll (?:create|save|put|place) (?:the |all )?(\w+) in ([^\s,\.]+)/gi,
      /I understand.*?(\w+) should (?:be|go) in ([^\s,\.]+)/gi,
      /(?:Creating|Saving|Putting) (\w+) in ([^\s,\.]+)/gi,
      /(\w+) will be (?:created|saved|placed) in ([^\s,\.]+)/gi
    ];

    for (const pattern of acknowledgmentPatterns) {
      let match;
      while ((match = pattern.exec(response)) !== null) {
        const [fullMatch, subject, location] = match;
        const key = this.inferPreferenceKey(subject);
        
        if (key) {
          preferences.push({
            key,
            value: location,
            confidence: 0.8, // Implicit understanding has slightly lower confidence
            rawText: fullMatch
          });
        }
      }
    }

    return preferences;
  }
}