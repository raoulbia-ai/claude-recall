import { MemoryService } from '../services/memory';
import { LoggingService } from '../services/logging';

export interface ToolSelection {
  name: string;
  params: any;
}

export interface InteractionLog {
  prompt: string;
  toolsSelected: ToolSelection[];
  executionResults: any[];
  databaseChanges?: any[];
  searchCallsMade?: number;
}

export class MockClaude {
  private complianceLevel = 0.5; // 50% compliance by default
  
  constructor(
    private memoryService: MemoryService,
    private logger: LoggingService
  ) {}
  
  setComplianceLevel(level: number): void {
    this.complianceLevel = Math.max(0, Math.min(1, level));
    this.logger.info('MockClaude', `Compliance level set to ${this.complianceLevel}`);
  }
  
  async simulateInteraction(prompt: string): Promise<InteractionLog> {
    this.logger.info('MockClaude', 'Simulating interaction', { prompt });
    
    // Select tools based on prompt
    const tools = await this.selectTools(prompt);
    
    // Execute tools
    const results: any[] = [];
    for (const tool of tools) {
      try {
        const result = await this.executeTool(tool);
        results.push({
          tool: tool.name,
          success: true,
          result
        });
      } catch (error) {
        results.push({
          tool: tool.name,
          success: false,
          error: (error as Error).message
        });
      }
    }
    
    return {
      prompt,
      toolsSelected: tools,
      executionResults: results
    };
  }
  
  private async selectTools(prompt: string): Promise<ToolSelection[]> {
    const tools: ToolSelection[] = [];
    const promptLower = prompt.toLowerCase();
    
    // Determine if should search based on compliance level
    const shouldSearch = Math.random() < this.complianceLevel;
    
    // Analyze prompt intent
    const intents = this.analyzePromptIntent(prompt);
    
    // Add search tool if compliant and relevant
    if (shouldSearch && (intents.createFile || intents.modifyFile || intents.needsContext)) {
      tools.push({
        name: 'mcp__claude-recall__search',
        params: {
          query: this.extractKeywords(prompt),
          limit: 10
        }
      });
    }
    
    // Add memory storage if mentioned
    if (intents.storeMemory) {
      tools.push({
        name: 'mcp__claude-recall__store_memory',
        params: {
          content: this.extractMemoryContent(prompt),
          metadata: {
            source: 'mock_claude',
            prompt: prompt.substring(0, 100)
          }
        }
      });
    }
    
    // Add file operations
    if (intents.createFile) {
      tools.push({
        name: 'create_file',
        params: {
          path: this.extractFilePath(prompt) || 'test.js',
          content: '// Generated by Mock Claude'
        }
      });
    }
    
    if (intents.modifyFile) {
      tools.push({
        name: 'edit_file',
        params: {
          path: this.extractFilePath(prompt) || 'test.js',
          changes: '// Modified by Mock Claude'
        }
      });
    }
    
    // Add retrieval if searching for information
    if (intents.retrieveInfo && !shouldSearch) {
      tools.push({
        name: 'mcp__claude-recall__retrieve_memory',
        params: {
          query: this.extractKeywords(prompt),
          limit: 5
        }
      });
    }
    
    return tools;
  }
  
  private analyzePromptIntent(prompt: string): {
    createFile: boolean;
    modifyFile: boolean;
    storeMemory: boolean;
    retrieveInfo: boolean;
    needsContext: boolean;
  } {
    const promptLower = prompt.toLowerCase();
    
    return {
      createFile: /create|new|add|generate|write/.test(promptLower) && 
                  /file|component|function|class|module/.test(promptLower),
      modifyFile: /edit|modify|update|change|fix|refactor/.test(promptLower),
      storeMemory: /save|store|remember|keep|record/.test(promptLower),
      retrieveInfo: /find|search|get|retrieve|what|where|how/.test(promptLower),
      needsContext: /based on|according to|following|similar to|like/.test(promptLower)
    };
  }
  
  private extractKeywords(prompt: string): string {
    // Extract meaningful keywords from prompt
    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for']);
    const words = prompt.toLowerCase()
      .replace(/[^\w\s]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 2 && !stopWords.has(word));
    
    // Return top 3-5 keywords
    return words.slice(0, 5).join(' ');
  }
  
  private extractMemoryContent(prompt: string): string {
    // Try to extract what should be remembered
    const matches = prompt.match(/remember|save|store\s+(.+?)(?:\.|$)/i);
    if (matches) {
      return matches[1].trim();
    }
    
    // Default to summarizing the prompt
    return prompt.substring(0, 200);
  }
  
  private extractFilePath(prompt: string): string | null {
    // Try to extract file path from prompt
    const patterns = [
      /(?:file|create|edit|modify)\s+['"`]?([^\s'"`]+\.[\w]+)/i,
      /(?:in|to|at)\s+['"`]?([^\s'"`]+\.[\w]+)/i,
      /([^\s]+\.(?:js|ts|jsx|tsx|py|java|cpp|go|rs))/i
    ];
    
    for (const pattern of patterns) {
      const match = prompt.match(pattern);
      if (match) {
        return match[1];
      }
    }
    
    return null;
  }
  
  private async executeTool(tool: ToolSelection): Promise<any> {
    this.logger.debug('MockClaude', `Executing tool: ${tool.name}`, tool.params);
    
    switch (tool.name) {
      case 'mcp__claude-recall__search':
        return await this.memoryService.search(tool.params.query);
        
      case 'mcp__claude-recall__store_memory':
        return await this.memoryService.store({
          key: `mock_${Date.now()}`,
          value: tool.params,
          type: 'mock',
          context: { sessionId: 'mock_session' }
        });
        
      case 'mcp__claude-recall__retrieve_memory':
        const results = await this.memoryService.search(tool.params.query);
        return results.slice(0, tool.params.limit || 5);
        
      case 'create_file':
      case 'edit_file':
        // Simulate file operation
        return {
          success: true,
          path: tool.params.path,
          operation: tool.name
        };
        
      default:
        return {
          success: true,
          message: `Tool ${tool.name} executed (simulated)`
        };
    }
  }
  
  // Advanced simulation methods
  async simulateComplexWorkflow(steps: Array<{
    prompt: string;
    expectedCompliance?: boolean;
    delay?: number;
  }>): Promise<InteractionLog[]> {
    const logs: InteractionLog[] = [];
    
    for (const step of steps) {
      if (step.delay) {
        await new Promise(resolve => setTimeout(resolve, step.delay));
      }
      
      // Adjust compliance if specified
      if (step.expectedCompliance !== undefined) {
        this.setComplianceLevel(step.expectedCompliance ? 1.0 : 0.0);
      }
      
      const log = await this.simulateInteraction(step.prompt);
      logs.push(log);
    }
    
    return logs;
  }
  
  generateTestPrompts(category: 'file_creation' | 'memory' | 'search' | 'mixed'): string[] {
    const prompts: Record<string, string[]> = {
      file_creation: [
        'Create a new React component called UserProfile.jsx',
        'Add a test file for the authentication module',
        'Generate a new API endpoint for user management',
        'Write a configuration file for the database connection'
      ],
      memory: [
        'Remember that all tests should be in the test-pasta folder',
        'Save the API key for the external service',
        'Store the user preferences for dark mode',
        'Keep track of the deployment configuration'
      ],
      search: [
        'Find all references to the authentication module',
        'Search for usage of the deprecated API',
        'What is the current database configuration?',
        'Where is the user profile component defined?'
      ],
      mixed: [
        'Based on the existing patterns, create a new service module',
        'Update the configuration file according to the team standards',
        'Find and fix all instances of the old API calls',
        'Create a test file similar to the existing authentication tests'
      ]
    };
    
    return prompts[category] || prompts.mixed;
  }
  
  // Compliance testing utilities
  async testComplianceLevels(): Promise<{
    level: number;
    searchRate: number;
    averageTools: number;
  }[]> {
    const results = [];
    const testPrompt = 'Create a new file called test.js with a function that validates user input';
    
    for (let level = 0; level <= 1; level += 0.1) {
      this.setComplianceLevel(level);
      
      let searchCount = 0;
      let totalTools = 0;
      const iterations = 10;
      
      for (let i = 0; i < iterations; i++) {
        const log = await this.simulateInteraction(testPrompt);
        
        if (log.toolsSelected.some(t => t.name.includes('search'))) {
          searchCount++;
        }
        totalTools += log.toolsSelected.length;
      }
      
      results.push({
        level: Math.round(level * 10) / 10,
        searchRate: searchCount / iterations,
        averageTools: totalTools / iterations
      });
    }
    
    return results;
  }
}