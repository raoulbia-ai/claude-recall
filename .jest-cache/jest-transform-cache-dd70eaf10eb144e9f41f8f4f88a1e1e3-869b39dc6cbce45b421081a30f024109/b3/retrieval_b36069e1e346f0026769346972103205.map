{"file":"/mnt/c/Users/ebiarao/repos/claude-recall/src/core/retrieval.ts","mappings":"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","names":[],"sources":["/mnt/c/Users/ebiarao/repos/claude-recall/src/core/retrieval.ts"],"sourcesContent":["import { MemoryStorage, Memory } from '../memory/storage';\n\nexport interface Context {\n  project_id?: string;\n  file_path?: string;\n  tool?: string;\n  type?: string;\n  timestamp?: number;\n  query?: string;  // User's actual query content\n  keywords?: string[];  // Extracted keywords from query\n}\n\nexport interface ScoredMemory extends Memory {\n  score: number;\n}\n\nexport class MemoryRetrieval {\n  constructor(private storage: MemoryStorage) {}\n  \n  // Extract keywords from user query for better semantic search\n  private extractKeywords(query: string): string[] {\n    if (!query) return [];\n    \n    // Common database-related keywords\n    const dbKeywords = ['database', 'db', 'postgres', 'postgresql', 'mysql', 'sqlite', \n                        'mongodb', 'redis', 'sql', 'nosql', 'storage'];\n    \n    // Convert query to lowercase for matching\n    const lowerQuery = query.toLowerCase();\n    \n    // Extract matching database keywords\n    const keywords = dbKeywords.filter(keyword => lowerQuery.includes(keyword));\n    \n    // Also extract significant words (3+ chars, not common words)\n    const commonWords = ['the', 'what', 'which', 'how', 'when', 'where', 'are', 'is', \n                         'do', 'we', 'use', 'using', 'for', 'and', 'or', 'in', 'to'];\n    \n    const words = lowerQuery.split(/\\s+/)\n      .filter(word => word.length >= 3 && !commonWords.includes(word));\n    \n    // Combine keywords and significant words\n    return [...new Set([...keywords, ...words])];\n  }\n  \n  findRelevant(context: Context, sortBy: 'relevance' | 'timestamp' = 'relevance'): ScoredMemory[] {\n    // Extract keywords from query if provided\n    if (context.query && !context.keywords) {\n      context.keywords = this.extractKeywords(context.query);\n    }\n\n    // Use enhanced search that looks for keywords in memory values\n    const candidates = this.storage.searchByContext(context);\n\n    if (sortBy === 'timestamp') {\n      // Sort by timestamp DESC (newest first)\n      const sorted = candidates\n        .map(memory => ({\n          ...memory,\n          score: 1.0 // Placeholder score for timestamp sorting\n        }))\n        .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));\n\n      // Return top results (no limit applied here, caller controls via slice)\n      return sorted;\n    }\n\n    // Default: relevance sorting\n    // Score and prioritize by memory type\n    const scored = candidates\n      .map(memory => ({\n        ...memory,\n        score: this.calculateRelevance(memory, context)\n      }))\n      .sort((a, b) => {\n        // First priority: memory type (project-knowledge > preference > tool-use)\n        const typeOrder: Record<string, number> = { 'project-knowledge': 3, 'preference': 2, 'tool-use': 1 };\n        const aTypeScore = typeOrder[a.type] || 0;\n        const bTypeScore = typeOrder[b.type] || 0;\n\n        if (aTypeScore !== bTypeScore) {\n          return bTypeScore - aTypeScore;\n        }\n\n        // Second priority: relevance score\n        return b.score - a.score;\n      });\n\n    // Return top 5 most relevant memories\n    return scored.slice(0, 5);\n  }\n  \n  private calculateRelevance(memory: Memory, context: Context): number {\n    let score = memory.relevance_score || 1.0;\n    \n    // Boost for keyword matches in memory value\n    if (context.keywords && context.keywords.length > 0) {\n      const memoryStr = JSON.stringify(memory.value).toLowerCase();\n      let keywordMatches = 0;\n      \n      for (const keyword of context.keywords) {\n        if (memoryStr.includes(keyword.toLowerCase())) {\n          keywordMatches++;\n          score *= 2.0;  // Double score for each keyword match\n        }\n      }\n      \n      // Extra boost if all keywords match\n      if (keywordMatches === context.keywords.length) {\n        score *= 1.5;\n      }\n    }\n    \n    // Decay over time (forgetting curve) - less aggressive for project-knowledge\n    const timestamp = memory.timestamp || Date.now();\n    const daysSince = (Date.now() - timestamp) / (1000 * 60 * 60 * 24);\n    const decayFactor = memory.type === 'project-knowledge' ? 0.9 : 0.5;\n    const halfLife = memory.type === 'project-knowledge' ? 30 : 7;\n    score *= Math.pow(decayFactor, daysSince / halfLife);\n    \n    // Boost for same project/file\n    if (memory.project_id && context.project_id && memory.project_id === context.project_id) {\n      score *= 1.5;\n    }\n    if (memory.file_path && context.file_path && memory.file_path === context.file_path) {\n      score *= 2.0;\n    }\n    \n    // Boost for frequently accessed memories\n    if (memory.access_count && memory.access_count > 0) {\n      score *= 1 + Math.log10(memory.access_count) * 0.1;\n    }\n    \n    // Boost for recent access\n    if (memory.last_accessed) {\n      const hoursSinceAccess = (Date.now() - memory.last_accessed) / (1000 * 60 * 60);\n      if (hoursSinceAccess < 24) {\n        score *= 1.2;\n      }\n    }\n    \n    return score;\n  }\n  \n  searchByKeyword(keyword: string): ScoredMemory[] {\n    const results = this.storage.search(keyword);\n    const context: Context = { timestamp: Date.now() };\n    \n    return results\n      .map(memory => ({\n        ...memory,\n        score: this.calculateRelevance(memory, context)\n      }))\n      .sort((a, b) => b.score - a.score);\n  }\n}"],"version":3}