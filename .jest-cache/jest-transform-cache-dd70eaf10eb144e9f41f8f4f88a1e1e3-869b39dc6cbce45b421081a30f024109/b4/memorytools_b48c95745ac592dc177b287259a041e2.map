{"file":"/mnt/c/Users/ebiarao/repos/claude-recall/src/mcp/tools/memory-tools.ts","mappings":"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","names":[],"sources":["/mnt/c/Users/ebiarao/repos/claude-recall/src/mcp/tools/memory-tools.ts"],"sourcesContent":["import { MemoryService } from '../../services/memory';\nimport { LoggingService } from '../../services/logging';\nimport { SearchMonitor } from '../../services/search-monitor';\nimport { MCPTool, MCPContext } from '../server';\n\nexport class MemoryTools {\n  private tools: MCPTool[] = [];\n  private searchMonitor: SearchMonitor;\n  \n  constructor(\n    private memoryService: MemoryService,\n    private logger: LoggingService\n  ) {\n    this.searchMonitor = SearchMonitor.getInstance();\n    this.registerTools();\n  }\n\n  // Claude-flow pattern: Validate input against schema\n  private validateInput(schema: any, input: any): void {\n    if (schema.required) {\n      for (const required of schema.required) {\n        if (!(required in input)) {\n          throw new Error(`Missing required field: ${required}`);\n        }\n      }\n    }\n\n    if (schema.properties) {\n      for (const [key, propSchema] of Object.entries(schema.properties)) {\n        if (key in input) {\n          const value = input[key];\n          const expectedType = (propSchema as any).type;\n          \n          if (expectedType === 'string' && typeof value !== 'string') {\n            throw new Error(`Field ${key} must be a string`);\n          } else if (expectedType === 'number' && typeof value !== 'number') {\n            throw new Error(`Field ${key} must be a number`);\n          } else if (expectedType === 'boolean' && typeof value !== 'boolean') {\n            throw new Error(`Field ${key} must be a boolean`);\n          } else if (expectedType === 'object' && typeof value !== 'object') {\n            throw new Error(`Field ${key} must be an object`);\n          }\n        }\n      }\n    }\n  }\n\n  // Claude-flow pattern: Execute tool with tracking\n  private async executeToolWithTracking(\n    tool: MCPTool,\n    input: any,\n    context: MCPContext\n  ): Promise<any> {\n    const startTime = Date.now();\n    const toolMeta = {\n      name: tool.name,\n      sessionId: context.sessionId,\n      startTime\n    };\n    \n    try {\n      // Validate input against schema\n      this.validateInput(tool.inputSchema, input);\n      \n      // Execute tool\n      const result = await tool.handler(input, context);\n      \n      // Track success\n      this.logger.info('ToolExecution', 'Tool completed', {\n        ...toolMeta,\n        duration: Date.now() - startTime,\n        success: true\n      });\n      \n      return result;\n    } catch (error) {\n      // Track failure\n      this.logger.error('ToolExecution', 'Tool failed', {\n        ...toolMeta,\n        duration: Date.now() - startTime,\n        error: (error as Error).message\n      });\n      \n      throw error;\n    }\n  }\n  \n  private registerTools(): void {\n    this.tools = [\n      {\n        name: 'mcp__claude-recall__store_memory',\n        description: 'Store a memory in Claude Recall',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            content: {\n              type: 'string',\n              description: 'Memory content to store'\n            },\n            metadata: {\n              type: 'object',\n              description: 'Optional metadata for the memory'\n            },\n            scope: {\n              type: 'string',\n              enum: ['universal', 'project'],\n              description: 'Memory scope: \"universal\" (available in all projects) or \"project\" (current project only). Default: unscoped (available everywhere for backward compatibility)'\n            }\n          },\n          required: ['content']\n        },\n        handler: this.handleStoreMemory.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__retrieve_memory',\n        description: 'Get relevant memories by ID, query, or recency. Use sortBy=\"timestamp\" for most recent memories.',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: {\n              type: 'string',\n              description: 'Search query to find relevant memories'\n            },\n            id: {\n              type: 'string',\n              description: 'Specific memory ID to retrieve'\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of memories to return (default: 10)'\n            },\n            sortBy: {\n              type: 'string',\n              enum: ['relevance', 'timestamp'],\n              description: 'Sort order: \"relevance\" (default, keyword-based) or \"timestamp\" (newest first)'\n            }\n          }\n        },\n        handler: this.handleRetrieveMemory.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__search',\n        description: 'Search through all memories',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: { \n              type: 'string', \n              description: 'Search query' \n            },\n            filters: {\n              type: 'object',\n              description: 'Optional filters to apply',\n              properties: {\n                type: {\n                  type: 'string',\n                  description: 'Filter by memory type'\n                },\n                projectId: {\n                  type: 'string',\n                  description: 'Filter by project ID (includes universal memories)'\n                },\n                globalSearch: {\n                  type: 'boolean',\n                  description: 'Search all projects (ignores projectId filter)'\n                }\n              }\n            },\n            limit: { \n              type: 'number', \n              description: 'Maximum number of results (default: 20)' \n            }\n          },\n          required: ['query']\n        },\n        handler: this.handleSearch.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__get_stats',\n        description: 'Get memory statistics',\n        inputSchema: {\n          type: 'object',\n          properties: {}\n        },\n        handler: this.handleGetStats.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__clear_context',\n        description: 'Clear current session context',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            confirm: {\n              type: 'boolean',\n              description: 'Confirmation to clear context'\n            }\n          },\n          required: ['confirm']\n        },\n        handler: this.handleClearContext.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__store_preferences',\n        description: 'Store extracted preferences from conversation analysis (Phase 2). Use this after analyzing conversation with analyze-for-preferences prompt.',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            preferences: {\n              type: 'array',\n              description: 'Array of extracted preferences from Claude Code analysis',\n              items: {\n                type: 'object',\n                properties: {\n                  key: { type: 'string', description: 'Preference key (e.g., \"test_location\", \"code_style\")' },\n                  value: { description: 'Preference value (string or object)' },\n                  confidence: { type: 'number', description: 'Confidence score (0.0-1.0)' },\n                  reasoning: { type: 'string', description: 'Why this is a preference' }\n                },\n                required: ['key', 'value', 'confidence']\n              }\n            },\n            sessionId: {\n              type: 'string',\n              description: 'Session ID for the analyzed conversation'\n            }\n          },\n          required: ['preferences']\n        },\n        handler: this.handleStorePreferences.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__get_recent_captures',\n        description: 'Get information about memories that were automatically captured in this session. Use this to see what information has already been stored.',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            limit: {\n              type: 'number',\n              description: 'Maximum number of recent captures to return (default: 5)'\n            }\n          }\n        },\n        handler: this.handleGetRecentCaptures.bind(this)\n      }\n    ];\n  }\n\n  /**\n   * Estimate tokens in search results\n   * Uses rough approximation: 1 token ≈ 4 characters\n   */\n  private estimateTokens(results: any[]): number {\n    let totalChars = 0;\n    for (const result of results) {\n      const content = typeof result.value === 'string' ? result.value : JSON.stringify(result.value);\n      totalChars += content.length;\n    }\n    // Rough token estimate: 1 token ≈ 4 characters\n    return Math.ceil(totalChars / 4);\n  }\n\n  /**\n   * Estimate tokens saved by using search vs alternatives\n   * - Loading all reference files: ~8,000 tokens\n   * - Repeating preferences in context: ~200 tokens per preference\n   */\n  private estimateTokenSavings(resultsCount: number, query: string): number {\n    if (resultsCount === 0) {\n      return 0;\n    }\n\n    // Detect what type of search this is based on query keywords\n    const lowerQuery = query.toLowerCase();\n    const isDevOpsSearch = ['git', 'test', 'deploy', 'build', 'docker', 'ci', 'cd', 'workflow'].some(kw => lowerQuery.includes(kw));\n    const isPreferenceSearch = ['prefer', 'style', 'convention', 'always', 'never'].some(kw => lowerQuery.includes(kw));\n\n    let baselineCost = 0;\n\n    if (isDevOpsSearch) {\n      // Alternative: Loading devops reference files (1,500 tokens each × 6 files)\n      baselineCost = 9000;\n    } else if (isPreferenceSearch) {\n      // Alternative: User repeating preferences (200 tokens each)\n      baselineCost = resultsCount * 200;\n    } else {\n      // Generic search - alternative is asking user to repeat (300 tokens per item)\n      baselineCost = resultsCount * 300;\n    }\n\n    return baselineCost;\n  }\n\n  private async handleStoreMemory(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { content, metadata, scope } = input;\n\n      if (!content || typeof content !== 'string') {\n        throw new Error('Content is required and must be a string');\n      }\n\n      const key = `memory_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      this.memoryService.store({\n        key,\n        value: {\n          content,\n          ...metadata,\n          sessionId: context.sessionId,\n          timestamp: context.timestamp\n        },\n        type: 'conversation',\n        context: {\n          sessionId: context.sessionId,\n          projectId: scope === 'project' ? context.projectId : undefined,\n          timestamp: context.timestamp,\n          scope: scope || null\n        }\n      });\n      \n      this.logger.info('MemoryTools', 'Memory stored successfully', {\n        key,\n        contentLength: content.length,\n        sessionId: context.sessionId\n      });\n      \n      return {\n        id: key,\n        success: true\n      };\n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to store memory', error);\n      throw error;\n    }\n  }\n  \n  private async handleRetrieveMemory(input: any, context: MCPContext): Promise<any> {\n    try {\n      let { query, id, limit = 10, sortBy } = input;\n\n      // Smart detection: Auto-detect timestamp sorting from query keywords\n      if (!sortBy && query) {\n        const timeKeywords = ['recent', 'latest', 'newest', 'last', 'new'];\n        const lowerQuery = query.toLowerCase();\n        if (timeKeywords.some(kw => lowerQuery.includes(kw))) {\n          sortBy = 'timestamp';\n          this.logger.debug('MemoryTools', 'Auto-detected timestamp sorting', { query });\n        }\n      }\n\n      // Default to relevance sorting\n      if (!sortBy) {\n        sortBy = 'relevance';\n      }\n\n      if (id) {\n        // Retrieve specific memory by ID\n        const memory = this.memoryService.retrieve(id);\n\n        if (!memory) {\n          return {\n            memories: [],\n            count: 0,\n            message: `Memory with ID ${id} not found`\n          };\n        }\n\n        return {\n          memories: [memory],\n          count: 1\n        };\n      }\n\n      if (query) {\n        // Search for relevant memories with sort option\n        const results = this.memoryService.search(query, sortBy);\n        const limitedResults = results.slice(0, limit);\n\n        return {\n          memories: limitedResults.map(r => ({\n            ...r,\n            relevanceScore: r.score\n          })),\n          count: limitedResults.length,\n          totalFound: results.length,\n          sortBy\n        };\n      }\n\n      // Get recent memories from context\n      const contextResults = this.memoryService.findRelevant({\n        sessionId: context.sessionId,\n        projectId: context.projectId,\n        timestamp: context.timestamp\n      }, sortBy);\n\n      const limitedResults = contextResults.slice(0, limit);\n\n      return {\n        memories: limitedResults.map(r => ({\n          ...r,\n          relevanceScore: r.score\n        })),\n        count: limitedResults.length,\n        sortBy\n      };\n\n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to retrieve memory', error);\n      throw error;\n    }\n  }\n  \n  private async handleSearch(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { query, filters, limit = 20 } = input;\n      \n      if (!query) {\n        throw new Error('Query is required');\n      }\n      \n      const results = this.memoryService.search(query);\n      \n      // Apply filters if provided\n      let filteredResults = results;\n      if (filters) {\n        filteredResults = results.filter(result => {\n          if (filters.type && result.type !== filters.type) {\n            return false;\n          }\n\n          // Global search: include all memories\n          if (filters.globalSearch) {\n            return true;\n          }\n\n          // Project-scoped search: include project + universal + unscoped memories\n          if (filters.projectId) {\n            return result.project_id === filters.projectId ||\n                   result.scope === 'universal' ||\n                   result.project_id === null;\n          }\n\n          return true;\n        });\n      }\n      \n      const limitedResults = filteredResults.slice(0, limit);\n\n      // Calculate token metrics\n      const resultTokens = this.estimateTokens(limitedResults);\n      const tokensSaved = this.estimateTokenSavings(limitedResults.length, query);\n\n      // Record the search for monitoring\n      this.searchMonitor.recordSearch(\n        query,\n        limitedResults.length,\n        context.sessionId,\n        'mcp',\n        { filters, totalResults: results.length, tokenMetrics: { resultTokens, tokensSaved } }\n      );\n\n      this.logger.info('MemoryTools', 'Search completed', {\n        query,\n        totalResults: results.length,\n        filteredResults: filteredResults.length,\n        returnedResults: limitedResults.length,\n        tokenMetrics: { resultTokens, tokensSaved }\n      });\n\n      return {\n        results: limitedResults.map(r => ({\n          id: r.key,\n          type: r.type,\n          content: r.value,\n          score: r.score,\n          timestamp: r.timestamp,\n          projectId: r.project_id,\n          filePath: r.file_path\n        })),\n        total: filteredResults.length,\n        query,\n        tokenMetrics: {\n          estimatedTokens: resultTokens,\n          estimatedTokensSaved: tokensSaved,\n          efficiency: tokensSaved > 0 ? `${Math.round((tokensSaved / (tokensSaved + resultTokens)) * 100)}%` : '0%'\n        }\n      };\n      \n    } catch (error) {\n      this.logger.error('MemoryTools', 'Search failed', error);\n      throw error;\n    }\n  }\n  \n  private async handleGetStats(input: any, context: MCPContext): Promise<any> {\n    try {\n      const stats = this.memoryService.getStats();\n      \n      this.logger.info('MemoryTools', 'Stats retrieved', {\n        totalMemories: stats.total,\n        sessionId: context.sessionId\n      });\n      \n      return {\n        totalMemories: stats.total,\n        categories: stats.byType,\n        sessionId: context.sessionId,\n        timestamp: new Date().toISOString()\n      };\n      \n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to get stats', error);\n      throw error;\n    }\n  }\n  \n  private async handleClearContext(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { confirm } = input;\n\n      if (!confirm) {\n        return {\n          cleared: false,\n          message: 'Confirmation required to clear context'\n        };\n      }\n\n      // In a real implementation, we would clear session-specific data\n      // For now, we'll just log the action\n      this.logger.info('MemoryTools', 'Context cleared', {\n        sessionId: context.sessionId,\n        timestamp: context.timestamp\n      });\n\n      return {\n        cleared: true,\n        count: 0, // In real implementation, return number of cleared items\n        message: 'Session context cleared successfully'\n      };\n\n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to clear context', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Phase 2: Store batch preferences from Claude Code analysis\n   */\n  private async handleStorePreferences(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { preferences, sessionId } = input;\n\n      if (!Array.isArray(preferences) || preferences.length === 0) {\n        throw new Error('Preferences must be a non-empty array');\n      }\n\n      // Validate each preference\n      for (const pref of preferences) {\n        if (!pref.key || typeof pref.key !== 'string') {\n          throw new Error('Each preference must have a string key');\n        }\n        if (pref.value === undefined) {\n          throw new Error('Each preference must have a value');\n        }\n        if (typeof pref.confidence !== 'number' || pref.confidence < 0 || pref.confidence > 1) {\n          throw new Error('Confidence must be a number between 0 and 1');\n        }\n      }\n\n      // Store each preference\n      const stored = [];\n      for (const pref of preferences) {\n        const memoryKey = `pref_${pref.key}_${Date.now()}`;\n\n        await this.memoryService.store({\n          key: memoryKey,\n          value: {\n            value: pref.value,\n            confidence: pref.confidence,\n            reasoning: pref.reasoning || '',\n            source: 'claude-analysis',\n            analyzedAt: Date.now(),\n            sessionId: sessionId || context.sessionId\n          },\n          type: 'preference',\n          context: {\n            sessionId: sessionId || context.sessionId,\n            timestamp: Date.now()\n          }\n        });\n\n        stored.push({\n          key: pref.key,\n          memoryId: memoryKey,\n          confidence: pref.confidence\n        });\n\n        this.logger.info('MemoryTools', 'Stored analyzed preference', {\n          key: pref.key,\n          confidence: pref.confidence,\n          sessionId: sessionId || context.sessionId\n        });\n      }\n\n      this.logger.info('MemoryTools', 'Batch preferences stored', {\n        count: stored.length,\n        sessionId: sessionId || context.sessionId\n      });\n\n      return {\n        success: true,\n        stored: stored.length,\n        preferences: stored,\n        message: `Successfully stored ${stored.length} preferences from analysis`\n      };\n\n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to store preferences', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get recently automatically-captured memories for this session\n   */\n  private async handleGetRecentCaptures(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { limit = 5 } = input;\n\n      // Search for recent auto-captured memories\n      // We look for memories with keys starting with \"auto_\" or having auto_capture context\n      const allMemories = this.memoryService.search('');\n\n      // Filter to auto-captured memories from recent sessions\n      const autoCaptures = allMemories\n        .filter(m => {\n          // Check if it's an auto-captured memory\n          if (m.key && (m.key.startsWith('auto_') || m.key.startsWith('pref_'))) {\n            return true;\n          }\n          // Check value for auto_capture indicator\n          if (m.value && typeof m.value === 'object') {\n            const val = m.value as any;\n            if (val.source === 'auto_capture' || val.type === 'auto_capture') {\n              return true;\n            }\n          }\n          return false;\n        })\n        .slice(0, limit * 2); // Get more than needed, then filter by time\n\n      // Sort by timestamp (newest first)\n      const sorted = autoCaptures.sort((a, b) => {\n        const timeA = a.timestamp || 0;\n        const timeB = b.timestamp || 0;\n        return timeB - timeA;\n      });\n\n      const recentCaptures = sorted.slice(0, limit);\n\n      // Format for display\n      const formatted = recentCaptures.map(m => ({\n        type: m.type,\n        content: this.extractCaptureContent(m),\n        confidence: this.extractConfidence(m),\n        timestamp: m.timestamp,\n        key: m.key\n      }));\n\n      this.logger.info('MemoryTools', 'Retrieved recent captures', {\n        count: formatted.length,\n        sessionId: context.sessionId\n      });\n\n      return {\n        captures: formatted,\n        count: formatted.length,\n        message: formatted.length > 0\n          ? `Found ${formatted.length} automatically captured memories`\n          : 'No automatic captures yet in this session',\n        tip: formatted.length === 0\n          ? 'Memories are captured automatically when you state preferences, provide project info, or make decisions.'\n          : 'Consider manually storing additional project details that were mentioned.'\n      };\n\n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to get recent captures', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Extract human-readable content from captured memory\n   */\n  private extractCaptureContent(memory: any): string {\n    if (typeof memory.value === 'string') {\n      return memory.value;\n    }\n\n    if (typeof memory.value === 'object' && memory.value !== null) {\n      const val = memory.value as any;\n      if (val.raw) return val.raw;\n      if (val.content) return val.content;\n      if (val.message) return val.message;\n      if (val.key && val.value) {\n        return `${val.key}: ${typeof val.value === 'object' ? JSON.stringify(val.value) : val.value}`;\n      }\n      // Fallback: stringify the object\n      return JSON.stringify(val);\n    }\n\n    return memory.key || 'Unknown content';\n  }\n\n  /**\n   * Extract confidence score from memory\n   */\n  private extractConfidence(memory: any): number {\n    if (typeof memory.value === 'object' && memory.value !== null) {\n      const val = memory.value as any;\n      if (typeof val.confidence === 'number') {\n        return val.confidence;\n      }\n    }\n    return 0.5; // Default confidence\n  }\n\n  getTools(): MCPTool[] {\n    return this.tools;\n  }\n}"],"version":3}