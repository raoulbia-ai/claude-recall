{"file":"/mnt/c/Users/ebiarao/repos/claude-recall/src/mcp/tools/memory-tools.ts","mappings":"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","names":[],"sources":["/mnt/c/Users/ebiarao/repos/claude-recall/src/mcp/tools/memory-tools.ts"],"sourcesContent":["import { MemoryService } from '../../services/memory';\nimport { LoggingService } from '../../services/logging';\nimport { SearchMonitor } from '../../services/search-monitor';\nimport { MCPTool, MCPContext } from '../server';\n\nexport class MemoryTools {\n  private tools: MCPTool[] = [];\n  private searchMonitor: SearchMonitor;\n  \n  constructor(\n    private memoryService: MemoryService,\n    private logger: LoggingService\n  ) {\n    this.searchMonitor = SearchMonitor.getInstance();\n    this.registerTools();\n  }\n\n  // Claude-flow pattern: Validate input against schema\n  private validateInput(schema: any, input: any): void {\n    if (schema.required) {\n      for (const required of schema.required) {\n        if (!(required in input)) {\n          throw new Error(`Missing required field: ${required}`);\n        }\n      }\n    }\n\n    if (schema.properties) {\n      for (const [key, propSchema] of Object.entries(schema.properties)) {\n        if (key in input) {\n          const value = input[key];\n          const expectedType = (propSchema as any).type;\n          \n          if (expectedType === 'string' && typeof value !== 'string') {\n            throw new Error(`Field ${key} must be a string`);\n          } else if (expectedType === 'number' && typeof value !== 'number') {\n            throw new Error(`Field ${key} must be a number`);\n          } else if (expectedType === 'boolean' && typeof value !== 'boolean') {\n            throw new Error(`Field ${key} must be a boolean`);\n          } else if (expectedType === 'object' && typeof value !== 'object') {\n            throw new Error(`Field ${key} must be an object`);\n          }\n        }\n      }\n    }\n  }\n\n  // Claude-flow pattern: Execute tool with tracking\n  private async executeToolWithTracking(\n    tool: MCPTool,\n    input: any,\n    context: MCPContext\n  ): Promise<any> {\n    const startTime = Date.now();\n    const toolMeta = {\n      name: tool.name,\n      sessionId: context.sessionId,\n      startTime\n    };\n    \n    try {\n      // Validate input against schema\n      this.validateInput(tool.inputSchema, input);\n      \n      // Execute tool\n      const result = await tool.handler(input, context);\n      \n      // Track success\n      this.logger.info('ToolExecution', 'Tool completed', {\n        ...toolMeta,\n        duration: Date.now() - startTime,\n        success: true\n      });\n      \n      return result;\n    } catch (error) {\n      // Track failure\n      this.logger.error('ToolExecution', 'Tool failed', {\n        ...toolMeta,\n        duration: Date.now() - startTime,\n        error: (error as Error).message\n      });\n      \n      throw error;\n    }\n  }\n  \n  private registerTools(): void {\n    this.tools = [\n      {\n        name: 'mcp__claude-recall__store_memory',\n        description: 'Store a memory in Claude Recall',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            content: { \n              type: 'string', \n              description: 'Memory content to store' \n            },\n            metadata: { \n              type: 'object', \n              description: 'Optional metadata for the memory' \n            }\n          },\n          required: ['content']\n        },\n        handler: this.handleStoreMemory.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__retrieve_memory',\n        description: 'Get relevant memories by ID or query',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: { \n              type: 'string', \n              description: 'Search query to find relevant memories' \n            },\n            id: { \n              type: 'string', \n              description: 'Specific memory ID to retrieve' \n            },\n            limit: { \n              type: 'number', \n              description: 'Maximum number of memories to return (default: 10)' \n            }\n          }\n        },\n        handler: this.handleRetrieveMemory.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__search',\n        description: 'Search through all memories',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: { \n              type: 'string', \n              description: 'Search query' \n            },\n            filters: { \n              type: 'object', \n              description: 'Optional filters to apply',\n              properties: {\n                type: { \n                  type: 'string', \n                  description: 'Filter by memory type' \n                },\n                projectId: { \n                  type: 'string', \n                  description: 'Filter by project ID' \n                }\n              }\n            },\n            limit: { \n              type: 'number', \n              description: 'Maximum number of results (default: 20)' \n            }\n          },\n          required: ['query']\n        },\n        handler: this.handleSearch.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__get_stats',\n        description: 'Get memory statistics',\n        inputSchema: {\n          type: 'object',\n          properties: {}\n        },\n        handler: this.handleGetStats.bind(this)\n      },\n      {\n        name: 'mcp__claude-recall__clear_context',\n        description: 'Clear current session context',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            confirm: { \n              type: 'boolean', \n              description: 'Confirmation to clear context' \n            }\n          },\n          required: ['confirm']\n        },\n        handler: this.handleClearContext.bind(this)\n      }\n    ];\n  }\n  \n  private async handleStoreMemory(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { content, metadata } = input;\n      \n      if (!content || typeof content !== 'string') {\n        throw new Error('Content is required and must be a string');\n      }\n      \n      const key = `memory_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      this.memoryService.store({\n        key,\n        value: {\n          content,\n          ...metadata,\n          sessionId: context.sessionId,\n          timestamp: context.timestamp\n        },\n        type: 'conversation',\n        context: {\n          sessionId: context.sessionId,\n          projectId: context.projectId,\n          timestamp: context.timestamp\n        }\n      });\n      \n      this.logger.info('MemoryTools', 'Memory stored successfully', {\n        key,\n        contentLength: content.length,\n        sessionId: context.sessionId\n      });\n      \n      return {\n        id: key,\n        success: true\n      };\n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to store memory', error);\n      throw error;\n    }\n  }\n  \n  private async handleRetrieveMemory(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { query, id, limit = 10 } = input;\n      \n      if (id) {\n        // Retrieve specific memory by ID\n        const memory = this.memoryService.retrieve(id);\n        \n        if (!memory) {\n          return {\n            memories: [],\n            count: 0,\n            message: `Memory with ID ${id} not found`\n          };\n        }\n        \n        return {\n          memories: [memory],\n          count: 1\n        };\n      }\n      \n      if (query) {\n        // Search for relevant memories\n        const results = this.memoryService.search(query);\n        const limitedResults = results.slice(0, limit);\n        \n        return {\n          memories: limitedResults.map(r => ({\n            ...r,\n            relevanceScore: r.score\n          })),\n          count: limitedResults.length,\n          totalFound: results.length\n        };\n      }\n      \n      // Get recent memories from context\n      const contextResults = this.memoryService.findRelevant({\n        sessionId: context.sessionId,\n        projectId: context.projectId,\n        timestamp: context.timestamp\n      });\n      \n      const limitedResults = contextResults.slice(0, limit);\n      \n      return {\n        memories: limitedResults.map(r => ({\n          ...r,\n          relevanceScore: r.score\n        })),\n        count: limitedResults.length\n      };\n      \n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to retrieve memory', error);\n      throw error;\n    }\n  }\n  \n  private async handleSearch(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { query, filters, limit = 20 } = input;\n      \n      if (!query) {\n        throw new Error('Query is required');\n      }\n      \n      const results = this.memoryService.search(query);\n      \n      // Apply filters if provided\n      let filteredResults = results;\n      if (filters) {\n        filteredResults = results.filter(result => {\n          if (filters.type && result.type !== filters.type) {\n            return false;\n          }\n          if (filters.projectId && result.project_id !== filters.projectId) {\n            return false;\n          }\n          return true;\n        });\n      }\n      \n      const limitedResults = filteredResults.slice(0, limit);\n      \n      // Record the search for monitoring\n      this.searchMonitor.recordSearch(\n        query,\n        limitedResults.length,\n        context.sessionId,\n        'mcp',\n        { filters, totalResults: results.length }\n      );\n      \n      this.logger.info('MemoryTools', 'Search completed', {\n        query,\n        totalResults: results.length,\n        filteredResults: filteredResults.length,\n        returnedResults: limitedResults.length\n      });\n      \n      return {\n        results: limitedResults.map(r => ({\n          id: r.key,\n          type: r.type,\n          content: r.value,\n          score: r.score,\n          timestamp: r.timestamp,\n          projectId: r.project_id,\n          filePath: r.file_path\n        })),\n        total: filteredResults.length,\n        query\n      };\n      \n    } catch (error) {\n      this.logger.error('MemoryTools', 'Search failed', error);\n      throw error;\n    }\n  }\n  \n  private async handleGetStats(input: any, context: MCPContext): Promise<any> {\n    try {\n      const stats = this.memoryService.getStats();\n      \n      this.logger.info('MemoryTools', 'Stats retrieved', {\n        totalMemories: stats.total,\n        sessionId: context.sessionId\n      });\n      \n      return {\n        totalMemories: stats.total,\n        categories: stats.byType,\n        sessionId: context.sessionId,\n        timestamp: new Date().toISOString()\n      };\n      \n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to get stats', error);\n      throw error;\n    }\n  }\n  \n  private async handleClearContext(input: any, context: MCPContext): Promise<any> {\n    try {\n      const { confirm } = input;\n      \n      if (!confirm) {\n        return {\n          cleared: false,\n          message: 'Confirmation required to clear context'\n        };\n      }\n      \n      // In a real implementation, we would clear session-specific data\n      // For now, we'll just log the action\n      this.logger.info('MemoryTools', 'Context cleared', {\n        sessionId: context.sessionId,\n        timestamp: context.timestamp\n      });\n      \n      return {\n        cleared: true,\n        count: 0, // In real implementation, return number of cleared items\n        message: 'Session context cleared successfully'\n      };\n      \n    } catch (error) {\n      this.logger.error('MemoryTools', 'Failed to clear context', error);\n      throw error;\n    }\n  }\n  \n  getTools(): MCPTool[] {\n    return this.tools;\n  }\n}"],"version":3}