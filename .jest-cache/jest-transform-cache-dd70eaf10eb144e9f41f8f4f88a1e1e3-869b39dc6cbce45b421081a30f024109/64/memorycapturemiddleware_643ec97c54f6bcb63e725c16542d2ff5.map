{"file":"/mnt/c/Users/ebiarao/repos/claude-recall/src/mcp/memory-capture-middleware.ts","mappings":"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","names":[],"sources":["/mnt/c/Users/ebiarao/repos/claude-recall/src/mcp/memory-capture-middleware.ts"],"sourcesContent":["import { MCPRequest, MCPResponse } from './server';\nimport { PreferenceExtractor } from '../services/preference-extractor';\nimport { ActionPatternDetector } from '../services/action-pattern-detector';\nimport { MemoryService } from '../services/memory';\nimport { LoggingService } from '../services/logging';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface MemoryPattern {\n  pattern: string;\n  type: string;\n  confidence: number;\n  extractionMode: string;\n}\n\ninterface MemoryPatternConfig {\n  preferencePatterns: MemoryPattern[];\n  actionPatterns: MemoryPattern[];\n  contextTriggers: {\n    highConfidenceWords: string[];\n    decisionIndicators: string[];\n    futureTense: string[];\n  };\n  captureSettings: {\n    minConfidence: number;\n    requireExplicitConfirmation: boolean;\n    batchProcessingDelay: number;\n    maxMemoriesPerSession: number;\n    deduplicationWindow: number;\n  };\n}\n\nexport class MemoryCaptureMiddleware {\n  private preferenceExtractor: PreferenceExtractor;\n  private actionDetector: ActionPatternDetector;\n  private memoryService: MemoryService;\n  private logger: LoggingService;\n  private config!: MemoryPatternConfig;\n  private recentCaptures: Map<string, number> = new Map();\n  private sessionMemoryCount: Map<string, number> = new Map();\n\n  constructor() {\n    this.preferenceExtractor = new PreferenceExtractor();\n    this.actionDetector = new ActionPatternDetector();\n    this.memoryService = MemoryService.getInstance();\n    this.logger = LoggingService.getInstance();\n    this.loadConfig();\n  }\n\n  private loadConfig(): void {\n    try {\n      // First try custom config location\n      const customConfigPath = process.env.CLAUDE_RECALL_PATTERNS_CONFIG;\n      const defaultConfigPath = path.join(__dirname, '../../config/memory-patterns.json');\n      \n      const configPath = customConfigPath && fs.existsSync(customConfigPath) \n        ? customConfigPath \n        : defaultConfigPath;\n\n      if (fs.existsSync(configPath)) {\n        const configContent = fs.readFileSync(configPath, 'utf-8');\n        this.config = JSON.parse(configContent);\n        this.logger.info('MemoryCaptureMiddleware', 'Loaded memory patterns config', { configPath });\n      } else {\n        // Use default config if file doesn't exist\n        this.config = this.getDefaultConfig();\n        this.logger.warn('MemoryCaptureMiddleware', 'Using default config, no config file found');\n      }\n    } catch (error) {\n      this.logger.error('MemoryCaptureMiddleware', 'Failed to load config, using defaults', error as Error);\n      this.config = this.getDefaultConfig();\n    }\n  }\n\n  private getDefaultConfig(): MemoryPatternConfig {\n    return {\n      preferencePatterns: [\n        {\n          pattern: \"(?:I prefer|prefer)\\\\s+([\\\\w\\\\s]+)\\\\s+(?:over|instead of)\\\\s+([\\\\w\\\\s]+)\",\n          type: \"preference\",\n          confidence: 0.9,\n          extractionMode: \"comparison\"\n        }\n      ],\n      actionPatterns: [],\n      contextTriggers: {\n        highConfidenceWords: [\"always\", \"never\", \"must\", \"prefer\"],\n        decisionIndicators: [\"decided\", \"choosing\", \"selected\"],\n        futureTense: [\"will\", \"going to\", \"from now on\"]\n      },\n      captureSettings: {\n        minConfidence: 0.7,\n        requireExplicitConfirmation: false,\n        batchProcessingDelay: 1000,\n        maxMemoriesPerSession: 50,\n        deduplicationWindow: 3600000\n      }\n    };\n  }\n\n  /**\n   * Process a request/response pair for automatic memory capture\n   */\n  async processForMemoryCapture(\n    request: MCPRequest,\n    response: MCPResponse,\n    sessionId: string\n  ): Promise<void> {\n    try {\n      // Don't capture from memory-related tools to avoid loops\n      if (request.method === 'tools/call' && \n          request.params?.name?.includes('memory')) {\n        return;\n      }\n\n      // Extract content to analyze\n      const contentToAnalyze = this.extractContent(request, response);\n      if (!contentToAnalyze) return;\n\n      // Check session memory limit\n      const sessionCount = this.sessionMemoryCount.get(sessionId) || 0;\n      if (sessionCount >= this.config.captureSettings.maxMemoriesPerSession) {\n        this.logger.debug('MemoryCaptureMiddleware', 'Session memory limit reached', { sessionId, count: sessionCount });\n        return;\n      }\n\n      // Analyze for patterns\n      const detectedMemories = await this.analyzeContent(contentToAnalyze, sessionId);\n\n      // Store unique memories\n      for (const memory of detectedMemories) {\n        if (this.shouldCapture(memory, sessionId)) {\n          await this.captureMemory(memory, sessionId);\n        }\n      }\n    } catch (error) {\n      this.logger.error('MemoryCaptureMiddleware', 'Error in memory capture', error as Error);\n    }\n  }\n\n  private extractContent(request: MCPRequest, response: MCPResponse): string | null {\n    let content = '';\n\n    // Extract from request\n    if (request.params?.arguments?.content) {\n      content += request.params.arguments.content + '\\n';\n    }\n\n    // Extract from response\n    if (response.result?.content) {\n      if (Array.isArray(response.result.content)) {\n        response.result.content.forEach((item: any) => {\n          if (item.text) content += item.text + '\\n';\n        });\n      } else if (typeof response.result.content === 'string') {\n        content += response.result.content + '\\n';\n      }\n    }\n\n    return content.trim() || null;\n  }\n\n  private async analyzeContent(content: string, sessionId: string): Promise<any[]> {\n    const memories: any[] = [];\n\n    // PRIORITY 1: Check for explicit \"remember\" commands\n    const rememberRegex = /(?:remember|Remember)\\s+(?:that\\s+)?(.+?)(?:[.!?]|$)/gi;\n    const rememberMatches = content.matchAll(rememberRegex);\n    \n    for (const match of rememberMatches) {\n      const memoryContent = match[1].trim();\n      if (memoryContent) {\n        memories.push({\n          type: 'explicit_memory',\n          content: memoryContent,\n          data: {\n            raw: memoryContent,\n            source: 'explicit_remember_command',\n            confidence: 1.0\n          },\n          confidence: 1.0,  // Always highest confidence\n          priority: 1  // Highest priority\n        });\n      }\n    }\n\n    // PRIORITY 2: Use configured preference patterns\n    for (const pattern of this.config.preferencePatterns) {\n      const regex = new RegExp(pattern.pattern, 'gi');\n      const matches = content.matchAll(regex);\n      \n      for (const match of matches) {\n        // Skip if this was already captured as explicit memory\n        if (match[0].toLowerCase().includes('remember')) continue;\n        \n        memories.push({\n          type: pattern.type,\n          content: match[0],\n          data: {\n            pattern: pattern.type,\n            captured: match.slice(1),\n            confidence: pattern.confidence,\n            extractionMode: pattern.extractionMode\n          },\n          confidence: pattern.confidence,\n          priority: 2\n        });\n      }\n    }\n\n    // PRIORITY 3: Use existing PreferenceExtractor\n    const preferences = this.preferenceExtractor.extractPreferences(content);\n    for (const pref of preferences) {\n      if (pref.confidence >= this.config.captureSettings.minConfidence) {\n        // Skip if already captured as explicit memory\n        if (pref.raw.toLowerCase().includes('remember')) continue;\n        \n        memories.push({\n          type: 'preference',\n          content: pref.raw,\n          data: {\n            key: pref.key,\n            value: pref.value,\n            confidence: pref.confidence\n          },\n          confidence: pref.confidence,\n          priority: 3\n        });\n      }\n    }\n\n    // Check for action patterns using configured patterns\n    for (const pattern of this.config.actionPatterns) {\n      const regex = new RegExp(pattern.pattern, 'gi');\n      const matches = content.matchAll(regex);\n      \n      for (const match of matches) {\n        memories.push({\n          type: pattern.type,\n          content: match[0],\n          data: {\n            pattern: pattern.type,\n            captured: match.slice(1),\n            confidence: pattern.confidence\n          },\n          confidence: pattern.confidence\n        });\n      }\n    }\n\n    // Check for high-confidence context triggers\n    const hasHighConfidenceContext = this.config.contextTriggers.highConfidenceWords.some(\n      word => content.toLowerCase().includes(word.toLowerCase())\n    );\n\n    if (hasHighConfidenceContext) {\n      // Boost confidence for all found patterns\n      memories.forEach(m => m.confidence = Math.min(1.0, m.confidence * 1.1));\n    }\n\n    return memories;\n  }\n\n  private shouldCapture(memory: any, sessionId: string): boolean {\n    // ALWAYS capture explicit \"remember\" commands\n    if (memory.type === 'explicit_memory' || memory.priority === 1) {\n      return true;\n    }\n\n    // Check confidence threshold for other types\n    if (memory.confidence < this.config.captureSettings.minConfidence) {\n      return false;\n    }\n\n    // Check for duplicates within deduplication window\n    const memoryKey = `${memory.type}:${memory.content}`;\n    const lastCapture = this.recentCaptures.get(memoryKey);\n    const now = Date.now();\n\n    if (lastCapture && (now - lastCapture) < this.config.captureSettings.deduplicationWindow) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private async captureMemory(memory: any, sessionId: string): Promise<void> {\n    try {\n      // Store using MemoryService\n      const stored = this.memoryService.store({\n        key: `auto_${memory.type}_${Date.now()}`,\n        value: memory.data,\n        type: memory.type,\n        context: {\n          projectId: sessionId,\n          type: 'auto_capture',\n          timestamp: Date.now()\n        }\n      });\n\n      // Update tracking\n      const memoryKey = `${memory.type}:${memory.content}`;\n      this.recentCaptures.set(memoryKey, Date.now());\n      \n      const currentCount = this.sessionMemoryCount.get(sessionId) || 0;\n      this.sessionMemoryCount.set(sessionId, currentCount + 1);\n\n      this.logger.info('MemoryCaptureMiddleware', 'Auto-captured memory', {\n        type: memory.type,\n        confidence: memory.confidence,\n        sessionId\n      });\n    } catch (error) {\n      this.logger.error('MemoryCaptureMiddleware', 'Failed to capture memory', error as Error);\n    }\n  }\n\n  /**\n   * Clean up old session data\n   */\n  cleanupSessions(): void {\n    // Clean up old captures\n    const now = Date.now();\n    const cutoff = now - this.config.captureSettings.deduplicationWindow;\n    \n    for (const [key, timestamp] of this.recentCaptures) {\n      if (timestamp < cutoff) {\n        this.recentCaptures.delete(key);\n      }\n    }\n\n    // Reset session counts periodically\n    if (this.sessionMemoryCount.size > 100) {\n      this.sessionMemoryCount.clear();\n    }\n  }\n\n  /**\n   * Reload configuration (useful for hot-reloading)\n   */\n  reloadConfig(): void {\n    this.loadConfig();\n    this.logger.info('MemoryCaptureMiddleware', 'Configuration reloaded');\n  }\n}"],"version":3}