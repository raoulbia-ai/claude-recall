0a8e198818c732b47b559ca9280d9cda
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const memory_enhancer_1 = require("../../src/services/memory-enhancer");
const memory_1 = require("../../src/services/memory");
const config_1 = require("../../src/services/config");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
describe('Intelligent Retrieval Integration Tests', () => {
    let memoryEnhancer;
    let memoryService;
    let testDbPath;
    beforeAll(() => {
        // Clear any existing singleton instance
        memory_1.MemoryService.instance = null;
        // Setup test database
        testDbPath = path.join(__dirname, '../fixtures/test-intelligent-retrieval.db');
        // Create fixtures directory if it doesn't exist
        const fixturesDir = path.dirname(testDbPath);
        if (!fs.existsSync(fixturesDir)) {
            fs.mkdirSync(fixturesDir, { recursive: true });
        }
        // Remove existing test database
        if (fs.existsSync(testDbPath)) {
            fs.unlinkSync(testDbPath);
        }
        // Mock config to use test database
        jest.spyOn(config_1.ConfigService.prototype, 'getDatabasePath').mockReturnValue(testDbPath);
        jest.spyOn(config_1.ConfigService.prototype, 'getProjectId').mockReturnValue('test-project');
        // Initialize services
        memoryService = memory_1.MemoryService.getInstance();
        memoryEnhancer = new memory_enhancer_1.MemoryEnhancer();
        // Populate test data
        setupTestData();
    });
    afterAll(() => {
        // Cleanup
        if (memoryService) {
            memoryService.close();
        }
        if (fs.existsSync(testDbPath)) {
            fs.unlinkSync(testDbPath);
        }
        jest.restoreAllMocks();
    });
    function setupTestData() {
        // Add test directory preference
        memoryService.storePreference({
            pattern: 'test directory',
            value: 'tests/',
            description: 'Tests should be saved in tests/ directory'
        }, {
            projectId: 'test-project',
            timestamp: Date.now()
        });
        // Add error history
        memoryService.store({
            key: 'error_fix_typeof',
            value: {
                error: 'TypeError: Cannot read property of undefined',
                file: 'auth.js',
                fix: 'Added null check before accessing property',
                line: 42
            },
            type: 'project-knowledge',
            context: {
                projectId: 'test-project',
                filePath: 'auth.js'
            }
        });
        // Add code style preferences
        memoryService.storePreference({
            pattern: 'arrow functions',
            value: 'prefer arrow functions for callbacks',
            examples: ['setTimeout(() => {}, 100)', 'array.map(x => x * 2)']
        }, {
            projectId: 'test-project'
        });
        memoryService.storePreference({
            pattern: 'async/await',
            value: 'use async/await instead of promises',
            examples: ['async function fetchData() { await api.get() }']
        }, {
            projectId: 'test-project'
        });
        // Add API conventions
        memoryService.store({
            key: 'api_conventions',
            value: {
                pattern: 'RESTful API',
                baseUrl: '/api/v1',
                conventions: {
                    endpoints: 'plural nouns (e.g., /users, /products)',
                    methods: 'GET, POST, PUT, DELETE',
                    responses: 'JSON with consistent structure'
                }
            },
            type: 'project-knowledge',
            context: {
                projectId: 'test-project'
            }
        });
    }
    describe('Real-world scenarios', () => {
        test('Scenario 1: User says "create a test for auth" → System retrieves test directory preference', async () => {
            const prompt = 'create a test for the user service';
            const results = await memoryEnhancer.enhanceSearch(prompt);
            // Should find the test directory preference
            const testDirMemory = results.find(m => m.value &&
                typeof m.value === 'object' &&
                (m.value.value?.includes('tests/') ||
                    m.value.description?.includes('tests/')));
            expect(testDirMemory).toBeDefined();
            expect(testDirMemory?.type).toBe('preference');
            expect(JSON.stringify(testDirMemory?.value)).toContain('tests/');
        });
        test('Scenario 2: User says "fix TypeError" → System retrieves previous TypeError fixes', async () => {
            const prompt = 'fix the undefined error in auth.js';
            const results = await memoryEnhancer.enhanceSearch(prompt);
            // Should find the previous TypeError fix
            const errorFixMemory = results.find(m => m.key === 'error_fix_typeof' ||
                (m.value && JSON.stringify(m.value).includes('TypeError')));
            expect(errorFixMemory).toBeDefined();
            expect(errorFixMemory?.type).toBe('project-knowledge');
            expect(errorFixMemory?.value).toHaveProperty('fix');
        });
        test('Scenario 3: User says "refactor to use async" → System retrieves async/await preferences', async () => {
            const prompt = 'refactor this function to use modern syntax';
            const results = await memoryEnhancer.enhanceSearch(prompt);
            // Should find async/await and arrow function preferences
            const asyncPref = results.find(m => m.value &&
                JSON.stringify(m.value).includes('async/await'));
            const arrowPref = results.find(m => m.value &&
                JSON.stringify(m.value).includes('arrow functions'));
            expect(asyncPref).toBeDefined();
            expect(arrowPref).toBeDefined();
            expect(asyncPref?.type).toBe('preference');
            expect(arrowPref?.type).toBe('preference');
        });
        test('Scenario 4: User says "add user endpoint" → System retrieves API conventions', async () => {
            const prompt = 'add a new API endpoint for products';
            const results = await memoryEnhancer.enhanceSearch(prompt);
            // Should find API conventions
            const apiMemory = results.find(m => m.key === 'api_conventions' ||
                (m.value && JSON.stringify(m.value).includes('RESTful')));
            expect(apiMemory).toBeDefined();
            expect(apiMemory?.type).toBe('project-knowledge');
            expect(apiMemory?.value).toHaveProperty('baseUrl');
            expect(apiMemory?.value).toHaveProperty('conventions');
        });
    });
    describe('Pattern detection integration', () => {
        test('should correctly identify test creation tasks without explicit "directory" mention', async () => {
            const prompts = [
                'create a test for auth module',
                'write tests for user service',
                'add unit test for login function',
                'make a test case for registration'
            ];
            for (const prompt of prompts) {
                const results = await memoryEnhancer.enhanceSearch(prompt);
                // Each should retrieve test directory preference
                const hasTestDirPref = results.some(m => JSON.stringify(m.value).includes('tests/'));
                expect(hasTestDirPref).toBe(true);
            }
        });
        test('should identify bug fix patterns and retrieve relevant fixes', async () => {
            // Test specific error types that we have data for
            const errorPrompt = 'fix TypeError in authentication';
            const results = await memoryEnhancer.enhanceSearch(errorPrompt);
            // Should find the TypeError fix we stored
            const hasTypeErrorFix = results.some(m => m.key === 'error_fix_typeof' ||
                (m.value && JSON.stringify(m.value).includes('TypeError')));
            expect(hasTypeErrorFix).toBe(true);
            // Test general bug fix patterns
            const bugPrompts = [
                'fix undefined error in auth.js',
                'resolve error in auth.js'
            ];
            for (const prompt of bugPrompts) {
                const bugResults = await memoryEnhancer.enhanceSearch(prompt);
                // Should find some relevant memory (either the TypeError fix or preferences)
                const hasRelevantMemory = bugResults.length > 0 && bugResults.some(m => m.type === 'project-knowledge' ||
                    m.type === 'preference' ||
                    (m.value && JSON.stringify(m.value).toLowerCase().includes('error')));
                expect(hasRelevantMemory).toBe(true);
            }
        });
    });
    describe('Performance requirements', () => {
        test('should complete all searches within 100ms', async () => {
            const prompts = [
                'create a test for user authentication service',
                'fix TypeError: Cannot read property length of undefined in utils.js',
                'refactor dashboard component to use hooks instead of class',
                'add REST API endpoint for product inventory management'
            ];
            for (const prompt of prompts) {
                const startTime = Date.now();
                await memoryEnhancer.enhanceSearch(prompt);
                const endTime = Date.now();
                expect(endTime - startTime).toBeLessThan(100);
            }
        });
        test('should handle large result sets efficiently', async () => {
            // Add many memories
            for (let i = 0; i < 100; i++) {
                memoryService.store({
                    key: `bulk_test_${i}`,
                    value: { data: `test data ${i}` },
                    type: 'project-knowledge',
                    context: { projectId: 'test-project' }
                });
            }
            const startTime = Date.now();
            const results = await memoryEnhancer.enhanceSearch('search for test data');
            const endTime = Date.now();
            expect(endTime - startTime).toBeLessThan(100);
            expect(results.length).toBeLessThanOrEqual(10); // Should limit results
        });
    });
    describe('Backwards compatibility', () => {
        test('should work when pattern detection returns empty results', async () => {
            const prompt = 'random query without patterns';
            const results = await memoryEnhancer.enhanceSearch(prompt);
            // Should still work and return any direct matches
            expect(Array.isArray(results)).toBe(true);
        });
        test('should preserve existing direct search functionality', async () => {
            // Store a memory that should be found by direct search
            memoryService.store({
                key: 'direct_match_test',
                value: 'specific test value for direct matching',
                type: 'project-knowledge',
                context: { projectId: 'test-project' }
            });
            const prompt = 'specific test value for direct matching';
            const results = await memoryEnhancer.enhanceSearch(prompt);
            // Should find the direct match
            const directMatch = results.find(m => m.key === 'direct_match_test');
            expect(directMatch).toBeDefined();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL21udC9jL1VzZXJzL2ViaWFyYW8vcmVwb3MvY2xhdWRlLXJlY2FsbC90ZXN0cy9pbnRlZ3JhdGlvbi9pbnRlbGxpZ2VudC1yZXRyaWV2YWwudGVzdC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHdFQUFvRTtBQUNwRSxzREFBMEQ7QUFHMUQsc0RBQTBEO0FBQzFELHVDQUF5QjtBQUN6QiwyQ0FBNkI7QUFFN0IsUUFBUSxDQUFDLHlDQUF5QyxFQUFFLEdBQUcsRUFBRTtJQUN2RCxJQUFJLGNBQThCLENBQUM7SUFDbkMsSUFBSSxhQUE0QixDQUFDO0lBQ2pDLElBQUksVUFBa0IsQ0FBQztJQUV2QixTQUFTLENBQUMsR0FBRyxFQUFFO1FBQ2Isd0NBQXdDO1FBQ3ZDLHNCQUFxQixDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFFdkMsc0JBQXNCO1FBQ3RCLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSwyQ0FBMkMsQ0FBQyxDQUFDO1FBRS9FLGdEQUFnRDtRQUNoRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUM7WUFDaEMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUNqRCxDQUFDO1FBRUQsZ0NBQWdDO1FBQ2hDLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQzlCLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDNUIsQ0FBQztRQUVELG1DQUFtQztRQUNuQyxJQUFJLENBQUMsS0FBSyxDQUFDLHNCQUFhLENBQUMsU0FBUyxFQUFFLGlCQUFpQixDQUFDLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ25GLElBQUks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aEQsSUFBSSxFQUFFLG1CQUFtQjtnQkFDekIsT0FBTyxFQUFFLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRTthQUN2QyxDQUFDLENBQUM7WUFFSCxNQUFNLE1BQU0sR0FBRyx5Q0FBeUMsQ0FBQztZQUN6RCxNQUFNLE9BQU8sR0FBRyxNQUFNLGNBQWMsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFM0QsK0JBQStCO1lBQy9CLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLG1CQUFtQixDQUFDLENBQUM7WUFDckUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvbW50L2MvVXNlcnMvZWJpYXJhby9yZXBvcy9jbGF1ZGUtcmVjYWxsL3Rlc3RzL2ludGVncmF0aW9uL2ludGVsbGlnZW50LXJldHJpZXZhbC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1lbW9yeUVuaGFuY2VyIH0gZnJvbSAnLi4vLi4vc3JjL3NlcnZpY2VzL21lbW9yeS1lbmhhbmNlcic7XG5pbXBvcnQgeyBNZW1vcnlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc3JjL3NlcnZpY2VzL21lbW9yeSc7XG5pbXBvcnQgeyBQYXR0ZXJuU2VydmljZSB9IGZyb20gJy4uLy4uL3NyYy9zZXJ2aWNlcy9wYXR0ZXJuLXNlcnZpY2UnO1xuaW1wb3J0IHsgTWVtb3J5U3RvcmFnZSB9IGZyb20gJy4uLy4uL3NyYy9tZW1vcnkvc3RvcmFnZSc7XG5pbXBvcnQgeyBDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc3JjL3NlcnZpY2VzL2NvbmZpZyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5kZXNjcmliZSgnSW50ZWxsaWdlbnQgUmV0cmlldmFsIEludGVncmF0aW9uIFRlc3RzJywgKCkgPT4ge1xuICBsZXQgbWVtb3J5RW5oYW5jZXI6IE1lbW9yeUVuaGFuY2VyO1xuICBsZXQgbWVtb3J5U2VydmljZTogTWVtb3J5U2VydmljZTtcbiAgbGV0IHRlc3REYlBhdGg6IHN0cmluZztcbiAgXG4gIGJlZm9yZUFsbCgoKSA9PiB7XG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHNpbmdsZXRvbiBpbnN0YW5jZVxuICAgIChNZW1vcnlTZXJ2aWNlIGFzIGFueSkuaW5zdGFuY2UgPSBudWxsO1xuICAgIFxuICAgIC8vIFNldHVwIHRlc3QgZGF0YWJhc2VcbiAgICB0ZXN0RGJQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2ZpeHR1cmVzL3Rlc3QtaW50ZWxsaWdlbnQtcmV0cmlldmFsLmRiJyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGZpeHR1cmVzIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgY29uc3QgZml4dHVyZXNEaXIgPSBwYXRoLmRpcm5hbWUodGVzdERiUGF0aCk7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpeHR1cmVzRGlyKSkge1xuICAgICAgZnMubWtkaXJTeW5jKGZpeHR1cmVzRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHRlc3QgZGF0YWJhc2VcbiAgICBpZiAoZnMuZXhpc3RzU3luYyh0ZXN0RGJQYXRoKSkge1xuICAgICAgZnMudW5saW5rU3luYyh0ZXN0RGJQYXRoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTW9jayBjb25maWcgdG8gdXNlIHRlc3QgZGF0YWJhc2VcbiAgICBqZXN0LnNweU9uKENvbmZpZ1NlcnZpY2UucHJvdG90eXBlLCAnZ2V0RGF0YWJhc2VQYXRoJykubW9ja1JldHVyblZhbHVlKHRlc3REYlBhdGgpO1xuICAgIGplc3Quc3B5T24oQ29uZmlnU2VydmljZS5wcm90b3R5cGUsICdnZXRQcm9qZWN0SWQnKS5tb2NrUmV0dXJuVmFsdWUoJ3Rlc3QtcHJvamVjdCcpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgc2VydmljZXNcbiAgICBtZW1vcnlTZXJ2aWNlID0gTWVtb3J5U2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgIG1lbW9yeUVuaGFuY2VyID0gbmV3IE1lbW9yeUVuaGFuY2VyKCk7XG4gICAgXG4gICAgLy8gUG9wdWxhdGUgdGVzdCBkYXRhXG4gICAgc2V0dXBUZXN0RGF0YSgpO1xuICB9KTtcbiAgXG4gIGFmdGVyQWxsKCgpID0+IHtcbiAgICAvLyBDbGVhbnVwXG4gICAgaWYgKG1lbW9yeVNlcnZpY2UpIHtcbiAgICAgIG1lbW9yeVNlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG4gICAgaWYgKGZzLmV4aXN0c1N5bmModGVzdERiUGF0aCkpIHtcbiAgICAgIGZzLnVubGlua1N5bmModGVzdERiUGF0aCk7XG4gICAgfVxuICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG4gIH0pO1xuICBcbiAgZnVuY3Rpb24gc2V0dXBUZXN0RGF0YSgpIHtcbiAgICAvLyBBZGQgdGVzdCBkaXJlY3RvcnkgcHJlZmVyZW5jZVxuICAgIG1lbW9yeVNlcnZpY2Uuc3RvcmVQcmVmZXJlbmNlKHtcbiAgICAgIHBhdHRlcm46ICd0ZXN0IGRpcmVjdG9yeScsXG4gICAgICB2YWx1ZTogJ3Rlc3RzLycsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Rlc3RzIHNob3VsZCBiZSBzYXZlZCBpbiB0ZXN0cy8gZGlyZWN0b3J5J1xuICAgIH0sIHtcbiAgICAgIHByb2plY3RJZDogJ3Rlc3QtcHJvamVjdCcsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBcbiAgICAvLyBBZGQgZXJyb3IgaGlzdG9yeVxuICAgIG1lbW9yeVNlcnZpY2Uuc3RvcmUoe1xuICAgICAga2V5OiAnZXJyb3JfZml4X3R5cGVvZicsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBlcnJvcjogJ1R5cGVFcnJvcjogQ2Fubm90IHJlYWQgcHJvcGVydHkgb2YgdW5kZWZpbmVkJyxcbiAgICAgICAgZmlsZTogJ2F1dGguanMnLFxuICAgICAgICBmaXg6ICdBZGRlZCBudWxsIGNoZWNrIGJlZm9yZSBhY2Nlc3NpbmcgcHJvcGVydHknLFxuICAgICAgICBsaW5lOiA0MlxuICAgICAgfSxcbiAgICAgIHR5cGU6ICdwcm9qZWN0LWtub3dsZWRnZScsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIHByb2plY3RJZDogJ3Rlc3QtcHJvamVjdCcsXG4gICAgICAgIGZpbGVQYXRoOiAnYXV0aC5qcydcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBBZGQgY29kZSBzdHlsZSBwcmVmZXJlbmNlc1xuICAgIG1lbW9yeVNlcnZpY2Uuc3RvcmVQcmVmZXJlbmNlKHtcbiAgICAgIHBhdHRlcm46ICdhcnJvdyBmdW5jdGlvbnMnLFxuICAgICAgdmFsdWU6ICdwcmVmZXIgYXJyb3cgZnVuY3Rpb25zIGZvciBjYWxsYmFja3MnLFxuICAgICAgZXhhbXBsZXM6IFsnc2V0VGltZW91dCgoKSA9PiB7fSwgMTAwKScsICdhcnJheS5tYXAoeCA9PiB4ICogMiknXVxuICAgIH0sIHtcbiAgICAgIHByb2plY3RJZDogJ3Rlc3QtcHJvamVjdCdcbiAgICB9KTtcbiAgICBcbiAgICBtZW1vcnlTZXJ2aWNlLnN0b3JlUHJlZmVyZW5jZSh7XG4gICAgICBwYXR0ZXJuOiAnYXN5bmMvYXdhaXQnLFxuICAgICAgdmFsdWU6ICd1c2UgYXN5bmMvYXdhaXQgaW5zdGVhZCBvZiBwcm9taXNlcycsXG4gICAgICBleGFtcGxlczogWydhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7IGF3YWl0IGFwaS5nZXQoKSB9J11cbiAgICB9LCB7XG4gICAgICBwcm9qZWN0SWQ6ICd0ZXN0LXByb2plY3QnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gQWRkIEFQSSBjb252ZW50aW9uc1xuICAgIG1lbW9yeVNlcnZpY2Uuc3RvcmUoe1xuICAgICAga2V5OiAnYXBpX2NvbnZlbnRpb25zJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHBhdHRlcm46ICdSRVNUZnVsIEFQSScsXG4gICAgICAgIGJhc2VVcmw6ICcvYXBpL3YxJyxcbiAgICAgICAgY29udmVudGlvbnM6IHtcbiAgICAgICAgICBlbmRwb2ludHM6ICdwbHVyYWwgbm91bnMgKGUuZy4sIC91c2VycywgL3Byb2R1Y3RzKScsXG4gICAgICAgICAgbWV0aG9kczogJ0dFVCwgUE9TVCwgUFVULCBERUxFVEUnLFxuICAgICAgICAgIHJlc3BvbnNlczogJ0pTT04gd2l0aCBjb25zaXN0ZW50IHN0cnVjdHVyZSdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHR5cGU6ICdwcm9qZWN0LWtub3dsZWRnZScsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIHByb2plY3RJZDogJ3Rlc3QtcHJvamVjdCdcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgZGVzY3JpYmUoJ1JlYWwtd29ybGQgc2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIHRlc3QoJ1NjZW5hcmlvIDE6IFVzZXIgc2F5cyBcImNyZWF0ZSBhIHRlc3QgZm9yIGF1dGhcIiDihpIgU3lzdGVtIHJldHJpZXZlcyB0ZXN0IGRpcmVjdG9yeSBwcmVmZXJlbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbXB0ID0gJ2NyZWF0ZSBhIHRlc3QgZm9yIHRoZSB1c2VyIHNlcnZpY2UnO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG1lbW9yeUVuaGFuY2VyLmVuaGFuY2VTZWFyY2gocHJvbXB0KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGZpbmQgdGhlIHRlc3QgZGlyZWN0b3J5IHByZWZlcmVuY2VcbiAgICAgIGNvbnN0IHRlc3REaXJNZW1vcnkgPSByZXN1bHRzLmZpbmQobSA9PiBcbiAgICAgICAgbS52YWx1ZSAmJiBcbiAgICAgICAgdHlwZW9mIG0udmFsdWUgPT09ICdvYmplY3QnICYmIFxuICAgICAgICAobS52YWx1ZS52YWx1ZT8uaW5jbHVkZXMoJ3Rlc3RzLycpIHx8IFxuICAgICAgICAgbS52YWx1ZS5kZXNjcmlwdGlvbj8uaW5jbHVkZXMoJ3Rlc3RzLycpKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHRlc3REaXJNZW1vcnkpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodGVzdERpck1lbW9yeT8udHlwZSkudG9CZSgncHJlZmVyZW5jZScpO1xuICAgICAgZXhwZWN0KEpTT04uc3RyaW5naWZ5KHRlc3REaXJNZW1vcnk/LnZhbHVlKSkudG9Db250YWluKCd0ZXN0cy8nKTtcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdTY2VuYXJpbyAyOiBVc2VyIHNheXMgXCJmaXggVHlwZUVycm9yXCIg4oaSIFN5c3RlbSByZXRyaWV2ZXMgcHJldmlvdXMgVHlwZUVycm9yIGZpeGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbXB0ID0gJ2ZpeCB0aGUgdW5kZWZpbmVkIGVycm9yIGluIGF1dGguanMnO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG1lbW9yeUVuaGFuY2VyLmVuaGFuY2VTZWFyY2gocHJvbXB0KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGZpbmQgdGhlIHByZXZpb3VzIFR5cGVFcnJvciBmaXhcbiAgICAgIGNvbnN0IGVycm9yRml4TWVtb3J5ID0gcmVzdWx0cy5maW5kKG0gPT4gXG4gICAgICAgIG0ua2V5ID09PSAnZXJyb3JfZml4X3R5cGVvZicgfHxcbiAgICAgICAgKG0udmFsdWUgJiYgSlNPTi5zdHJpbmdpZnkobS52YWx1ZSkuaW5jbHVkZXMoJ1R5cGVFcnJvcicpKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGVycm9yRml4TWVtb3J5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGVycm9yRml4TWVtb3J5Py50eXBlKS50b0JlKCdwcm9qZWN0LWtub3dsZWRnZScpO1xuICAgICAgZXhwZWN0KGVycm9yRml4TWVtb3J5Py52YWx1ZSkudG9IYXZlUHJvcGVydHkoJ2ZpeCcpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ1NjZW5hcmlvIDM6IFVzZXIgc2F5cyBcInJlZmFjdG9yIHRvIHVzZSBhc3luY1wiIOKGkiBTeXN0ZW0gcmV0cmlldmVzIGFzeW5jL2F3YWl0IHByZWZlcmVuY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbXB0ID0gJ3JlZmFjdG9yIHRoaXMgZnVuY3Rpb24gdG8gdXNlIG1vZGVybiBzeW50YXgnO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG1lbW9yeUVuaGFuY2VyLmVuaGFuY2VTZWFyY2gocHJvbXB0KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGZpbmQgYXN5bmMvYXdhaXQgYW5kIGFycm93IGZ1bmN0aW9uIHByZWZlcmVuY2VzXG4gICAgICBjb25zdCBhc3luY1ByZWYgPSByZXN1bHRzLmZpbmQobSA9PiBcbiAgICAgICAgbS52YWx1ZSAmJiBcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkobS52YWx1ZSkuaW5jbHVkZXMoJ2FzeW5jL2F3YWl0JylcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnN0IGFycm93UHJlZiA9IHJlc3VsdHMuZmluZChtID0+IFxuICAgICAgICBtLnZhbHVlICYmIFxuICAgICAgICBKU09OLnN0cmluZ2lmeShtLnZhbHVlKS5pbmNsdWRlcygnYXJyb3cgZnVuY3Rpb25zJylcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGV4cGVjdChhc3luY1ByZWYpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoYXJyb3dQcmVmKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGFzeW5jUHJlZj8udHlwZSkudG9CZSgncHJlZmVyZW5jZScpO1xuICAgICAgZXhwZWN0KGFycm93UHJlZj8udHlwZSkudG9CZSgncHJlZmVyZW5jZScpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ1NjZW5hcmlvIDQ6IFVzZXIgc2F5cyBcImFkZCB1c2VyIGVuZHBvaW50XCIg4oaSIFN5c3RlbSByZXRyaWV2ZXMgQVBJIGNvbnZlbnRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbXB0ID0gJ2FkZCBhIG5ldyBBUEkgZW5kcG9pbnQgZm9yIHByb2R1Y3RzJztcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtZW1vcnlFbmhhbmNlci5lbmhhbmNlU2VhcmNoKHByb21wdCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBmaW5kIEFQSSBjb252ZW50aW9uc1xuICAgICAgY29uc3QgYXBpTWVtb3J5ID0gcmVzdWx0cy5maW5kKG0gPT4gXG4gICAgICAgIG0ua2V5ID09PSAnYXBpX2NvbnZlbnRpb25zJyB8fFxuICAgICAgICAobS52YWx1ZSAmJiBKU09OLnN0cmluZ2lmeShtLnZhbHVlKS5pbmNsdWRlcygnUkVTVGZ1bCcpKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGFwaU1lbW9yeSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChhcGlNZW1vcnk/LnR5cGUpLnRvQmUoJ3Byb2plY3Qta25vd2xlZGdlJyk7XG4gICAgICBleHBlY3QoYXBpTWVtb3J5Py52YWx1ZSkudG9IYXZlUHJvcGVydHkoJ2Jhc2VVcmwnKTtcbiAgICAgIGV4cGVjdChhcGlNZW1vcnk/LnZhbHVlKS50b0hhdmVQcm9wZXJ0eSgnY29udmVudGlvbnMnKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnUGF0dGVybiBkZXRlY3Rpb24gaW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNvcnJlY3RseSBpZGVudGlmeSB0ZXN0IGNyZWF0aW9uIHRhc2tzIHdpdGhvdXQgZXhwbGljaXQgXCJkaXJlY3RvcnlcIiBtZW50aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbXB0cyA9IFtcbiAgICAgICAgJ2NyZWF0ZSBhIHRlc3QgZm9yIGF1dGggbW9kdWxlJyxcbiAgICAgICAgJ3dyaXRlIHRlc3RzIGZvciB1c2VyIHNlcnZpY2UnLFxuICAgICAgICAnYWRkIHVuaXQgdGVzdCBmb3IgbG9naW4gZnVuY3Rpb24nLFxuICAgICAgICAnbWFrZSBhIHRlc3QgY2FzZSBmb3IgcmVnaXN0cmF0aW9uJ1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBwcm9tcHQgb2YgcHJvbXB0cykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbWVtb3J5RW5oYW5jZXIuZW5oYW5jZVNlYXJjaChwcm9tcHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gRWFjaCBzaG91bGQgcmV0cmlldmUgdGVzdCBkaXJlY3RvcnkgcHJlZmVyZW5jZVxuICAgICAgICBjb25zdCBoYXNUZXN0RGlyUHJlZiA9IHJlc3VsdHMuc29tZShtID0+IFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG0udmFsdWUpLmluY2x1ZGVzKCd0ZXN0cy8nKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGhhc1Rlc3REaXJQcmVmKS50b0JlKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ3Nob3VsZCBpZGVudGlmeSBidWcgZml4IHBhdHRlcm5zIGFuZCByZXRyaWV2ZSByZWxldmFudCBmaXhlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3Qgc3BlY2lmaWMgZXJyb3IgdHlwZXMgdGhhdCB3ZSBoYXZlIGRhdGEgZm9yXG4gICAgICBjb25zdCBlcnJvclByb21wdCA9ICdmaXggVHlwZUVycm9yIGluIGF1dGhlbnRpY2F0aW9uJztcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtZW1vcnlFbmhhbmNlci5lbmhhbmNlU2VhcmNoKGVycm9yUHJvbXB0KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGZpbmQgdGhlIFR5cGVFcnJvciBmaXggd2Ugc3RvcmVkXG4gICAgICBjb25zdCBoYXNUeXBlRXJyb3JGaXggPSByZXN1bHRzLnNvbWUobSA9PiBcbiAgICAgICAgbS5rZXkgPT09ICdlcnJvcl9maXhfdHlwZW9mJyB8fFxuICAgICAgICAobS52YWx1ZSAmJiBKU09OLnN0cmluZ2lmeShtLnZhbHVlKS5pbmNsdWRlcygnVHlwZUVycm9yJykpXG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QoaGFzVHlwZUVycm9yRml4KS50b0JlKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IGdlbmVyYWwgYnVnIGZpeCBwYXR0ZXJuc1xuICAgICAgY29uc3QgYnVnUHJvbXB0cyA9IFtcbiAgICAgICAgJ2ZpeCB1bmRlZmluZWQgZXJyb3IgaW4gYXV0aC5qcycsXG4gICAgICAgICdyZXNvbHZlIGVycm9yIGluIGF1dGguanMnXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHByb21wdCBvZiBidWdQcm9tcHRzKSB7XG4gICAgICAgIGNvbnN0IGJ1Z1Jlc3VsdHMgPSBhd2FpdCBtZW1vcnlFbmhhbmNlci5lbmhhbmNlU2VhcmNoKHByb21wdCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgZmluZCBzb21lIHJlbGV2YW50IG1lbW9yeSAoZWl0aGVyIHRoZSBUeXBlRXJyb3IgZml4IG9yIHByZWZlcmVuY2VzKVxuICAgICAgICBjb25zdCBoYXNSZWxldmFudE1lbW9yeSA9IGJ1Z1Jlc3VsdHMubGVuZ3RoID4gMCAmJiBidWdSZXN1bHRzLnNvbWUobSA9PiBcbiAgICAgICAgICBtLnR5cGUgPT09ICdwcm9qZWN0LWtub3dsZWRnZScgfHwgXG4gICAgICAgICAgbS50eXBlID09PSAncHJlZmVyZW5jZScgfHxcbiAgICAgICAgICAobS52YWx1ZSAmJiBKU09OLnN0cmluZ2lmeShtLnZhbHVlKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdlcnJvcicpKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGhhc1JlbGV2YW50TWVtb3J5KS50b0JlKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSByZXF1aXJlbWVudHMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNvbXBsZXRlIGFsbCBzZWFyY2hlcyB3aXRoaW4gMTAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9tcHRzID0gW1xuICAgICAgICAnY3JlYXRlIGEgdGVzdCBmb3IgdXNlciBhdXRoZW50aWNhdGlvbiBzZXJ2aWNlJyxcbiAgICAgICAgJ2ZpeCBUeXBlRXJyb3I6IENhbm5vdCByZWFkIHByb3BlcnR5IGxlbmd0aCBvZiB1bmRlZmluZWQgaW4gdXRpbHMuanMnLFxuICAgICAgICAncmVmYWN0b3IgZGFzaGJvYXJkIGNvbXBvbmVudCB0byB1c2UgaG9va3MgaW5zdGVhZCBvZiBjbGFzcycsXG4gICAgICAgICdhZGQgUkVTVCBBUEkgZW5kcG9pbnQgZm9yIHByb2R1Y3QgaW52ZW50b3J5IG1hbmFnZW1lbnQnXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHByb21wdCBvZiBwcm9tcHRzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGF3YWl0IG1lbW9yeUVuaGFuY2VyLmVuaGFuY2VTZWFyY2gocHJvbXB0KTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDEwMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSByZXN1bHQgc2V0cyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFkZCBtYW55IG1lbW9yaWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICAgIG1lbW9yeVNlcnZpY2Uuc3RvcmUoe1xuICAgICAgICAgIGtleTogYGJ1bGtfdGVzdF8ke2l9YCxcbiAgICAgICAgICB2YWx1ZTogeyBkYXRhOiBgdGVzdCBkYXRhICR7aX1gIH0sXG4gICAgICAgICAgdHlwZTogJ3Byb2plY3Qta25vd2xlZGdlJyxcbiAgICAgICAgICBjb250ZXh0OiB7IHByb2plY3RJZDogJ3Rlc3QtcHJvamVjdCcgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtZW1vcnlFbmhhbmNlci5lbmhhbmNlU2VhcmNoKCdzZWFyY2ggZm9yIHRlc3QgZGF0YScpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMCk7IC8vIFNob3VsZCBsaW1pdCByZXN1bHRzXG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ0JhY2t3YXJkcyBjb21wYXRpYmlsaXR5JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB3b3JrIHdoZW4gcGF0dGVybiBkZXRlY3Rpb24gcmV0dXJucyBlbXB0eSByZXN1bHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbXB0ID0gJ3JhbmRvbSBxdWVyeSB3aXRob3V0IHBhdHRlcm5zJztcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtZW1vcnlFbmhhbmNlci5lbmhhbmNlU2VhcmNoKHByb21wdCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBzdGlsbCB3b3JrIGFuZCByZXR1cm4gYW55IGRpcmVjdCBtYXRjaGVzXG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgcHJlc2VydmUgZXhpc3RpbmcgZGlyZWN0IHNlYXJjaCBmdW5jdGlvbmFsaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU3RvcmUgYSBtZW1vcnkgdGhhdCBzaG91bGQgYmUgZm91bmQgYnkgZGlyZWN0IHNlYXJjaFxuICAgICAgbWVtb3J5U2VydmljZS5zdG9yZSh7XG4gICAgICAgIGtleTogJ2RpcmVjdF9tYXRjaF90ZXN0JyxcbiAgICAgICAgdmFsdWU6ICdzcGVjaWZpYyB0ZXN0IHZhbHVlIGZvciBkaXJlY3QgbWF0Y2hpbmcnLFxuICAgICAgICB0eXBlOiAncHJvamVjdC1rbm93bGVkZ2UnLFxuICAgICAgICBjb250ZXh0OiB7IHByb2plY3RJZDogJ3Rlc3QtcHJvamVjdCcgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHByb21wdCA9ICdzcGVjaWZpYyB0ZXN0IHZhbHVlIGZvciBkaXJlY3QgbWF0Y2hpbmcnO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG1lbW9yeUVuaGFuY2VyLmVuaGFuY2VTZWFyY2gocHJvbXB0KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGZpbmQgdGhlIGRpcmVjdCBtYXRjaFxuICAgICAgY29uc3QgZGlyZWN0TWF0Y2ggPSByZXN1bHRzLmZpbmQobSA9PiBtLmtleSA9PT0gJ2RpcmVjdF9tYXRjaF90ZXN0Jyk7XG4gICAgICBleHBlY3QoZGlyZWN0TWF0Y2gpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9