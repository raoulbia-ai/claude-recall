{"file":"/mnt/c/Users/ebiarao/repos/claude-recall/src/services/preference-analyzer.ts","mappings":"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","names":[],"sources":["/mnt/c/Users/ebiarao/repos/claude-recall/src/services/preference-analyzer.ts"],"sourcesContent":["/**\n * Preference Analyzer Service\n * Phase 2: Automatic preference detection and analysis triggers\n *\n * This service:\n * 1. Detects preference signals in tool calls (keywords, patterns)\n * 2. Suggests when Claude Code should analyze conversations\n * 3. Stores a \"pending-analysis\" memory that appears in active context\n * 4. Claude Code sees the suggestion and can analyze using the prompt template\n */\n\nimport { LoggingService } from './logging';\nimport { MemoryService } from './memory';\nimport { SessionManager, ConversationTurn } from '../mcp/session-manager';\n\nexport interface PreferenceSignal {\n  keyword: string;\n  confidence: number;\n  context: string;\n}\n\nexport interface AnalysisSuggestion {\n  sessionId: string;\n  reason: string;\n  conversationTurns: number;\n  preferenceSignals: number;\n  suggestedAt: number;\n}\n\nexport class PreferenceAnalyzer {\n  private logger: LoggingService;\n  private memoryService: MemoryService;\n  private sessionManager: SessionManager;\n\n  // Keywords that indicate preference statements\n  private readonly PREFERENCE_KEYWORDS = [\n    'prefer', 'always', 'never', 'use', 'avoid',\n    'like', 'dislike', 'should', 'shouldn\\'t',\n    'better', 'worse', 'instead', 'rather',\n    'convention', 'standard', 'practice', 'pattern',\n    'remember', 'save', 'keep', 'store'\n  ];\n\n  // Keywords that indicate corrections (learning opportunities)\n  private readonly CORRECTION_KEYWORDS = [\n    'no', 'wrong', 'incorrect', 'actually', 'meant',\n    'fix', 'change', 'correct', 'should be',\n    'not like that', 'different', 'instead'\n  ];\n\n  constructor(\n    logger: LoggingService,\n    memoryService: MemoryService,\n    sessionManager: SessionManager\n  ) {\n    this.logger = logger;\n    this.memoryService = memoryService;\n    this.sessionManager = sessionManager;\n  }\n\n  /**\n   * Detect if a tool input/output contains preference signals\n   * Returns true if preference keywords are found\n   */\n  detectPreferenceSignals(input: any, output: any): PreferenceSignal[] {\n    const signals: PreferenceSignal[] = [];\n\n    // Check input text for preference keywords\n    const inputText = this.extractText(input);\n    signals.push(...this.findKeywords(inputText, this.PREFERENCE_KEYWORDS, 'input'));\n\n    // Check output text for correction keywords\n    const outputText = this.extractText(output);\n    signals.push(...this.findKeywords(outputText, this.CORRECTION_KEYWORDS, 'output'));\n\n    return signals;\n  }\n\n  /**\n   * Extract text from various input/output formats\n   */\n  private extractText(data: any): string {\n    if (typeof data === 'string') {\n      return data.toLowerCase();\n    }\n\n    if (typeof data === 'object' && data !== null) {\n      // Handle common structures\n      if (data.content) return this.extractText(data.content);\n      if (data.text) return this.extractText(data.text);\n      if (data.message) return this.extractText(data.message);\n\n      // Flatten all string values\n      return Object.values(data)\n        .filter(v => typeof v === 'string')\n        .join(' ')\n        .toLowerCase();\n    }\n\n    return '';\n  }\n\n  /**\n   * Find preference keywords in text\n   */\n  private findKeywords(\n    text: string,\n    keywords: string[],\n    context: string\n  ): PreferenceSignal[] {\n    const signals: PreferenceSignal[] = [];\n\n    for (const keyword of keywords) {\n      if (text.includes(keyword)) {\n        signals.push({\n          keyword,\n          confidence: this.calculateKeywordConfidence(keyword, text),\n          context\n        });\n      }\n    }\n\n    return signals;\n  }\n\n  /**\n   * Calculate confidence based on keyword strength and context\n   */\n  private calculateKeywordConfidence(keyword: string, text: string): number {\n    // Base confidence\n    let confidence = 0.5;\n\n    // Strong keywords\n    const strongKeywords = ['always', 'never', 'prefer', 'convention', 'standard'];\n    if (strongKeywords.includes(keyword)) {\n      confidence = 0.8;\n    }\n\n    // Boost if appears multiple times\n    const occurrences = (text.match(new RegExp(keyword, 'g')) || []).length;\n    if (occurrences > 1) {\n      confidence = Math.min(1.0, confidence + 0.1 * (occurrences - 1));\n    }\n\n    return confidence;\n  }\n\n  /**\n   * Check if session should be analyzed and create suggestion\n   * This is called after each tool call\n   */\n  async checkAndSuggestAnalysis(sessionId: string): Promise<void> {\n    // Check if session meets analysis criteria\n    if (!this.sessionManager.shouldAnalyzeSession(sessionId)) {\n      return;\n    }\n\n    const session = this.sessionManager.getSession(sessionId);\n    if (!session) {\n      return;\n    }\n\n    // Create analysis suggestion\n    const suggestion: AnalysisSuggestion = {\n      sessionId,\n      reason: this.generateReason(session),\n      conversationTurns: session.conversationHistory?.length || 0,\n      preferenceSignals: session.preferenceSignalCount || 0,\n      suggestedAt: Date.now()\n    };\n\n    // Store as a special memory type that appears in active context\n    await this.createAnalysisSuggestionMemory(suggestion);\n\n    this.logger.info('PreferenceAnalyzer', 'Analysis suggested', {\n      sessionId,\n      reason: suggestion.reason\n    });\n  }\n\n  /**\n   * Generate reason text for why analysis is suggested\n   */\n  private generateReason(session: any): string {\n    const turns = session.conversationHistory?.length || 0;\n    const signals = session.preferenceSignalCount || 0;\n    const lastAnalyzed = session.lastAnalyzedTurn || 0;\n    const unanalyzed = turns - lastAnalyzed;\n\n    if (signals >= 3) {\n      return `Detected ${signals} preference signals in recent conversation`;\n    }\n\n    if (unanalyzed >= 5) {\n      return `${unanalyzed} conversation turns since last analysis`;\n    }\n\n    return 'Time for preference analysis';\n  }\n\n  /**\n   * Create a special \"analysis-suggestion\" memory\n   * This will appear in the active context resource, making it visible to Claude Code\n   */\n  private async createAnalysisSuggestionMemory(suggestion: AnalysisSuggestion): Promise<void> {\n    const key = `analysis-suggestion-${suggestion.sessionId}`;\n\n    const value = {\n      type: 'analysis-suggestion',\n      message: `ðŸ’¡ **Preference Analysis Suggested**\\n\\nI've noticed patterns in our conversation that might contain preferences worth remembering.\\n\\n**Details:**\\n- Reason: ${suggestion.reason}\\n- Conversation turns: ${suggestion.conversationTurns}\\n- Preference signals detected: ${suggestion.preferenceSignals}\\n\\n**What to do:**\\nYou can ask me to analyze our conversation by saying:\\n\"Can you analyze our conversation for preferences?\"\\n\\nI'll use the \\`analyze-for-preferences\\` prompt to extract any coding preferences, conventions, or patterns from our discussion.`,\n      ...suggestion\n    };\n\n    await this.memoryService.store({\n      key,\n      value,\n      type: 'analysis-suggestion',\n      context: {\n        sessionId: suggestion.sessionId,\n        timestamp: Date.now()\n      }\n    });\n\n    this.logger.debug('PreferenceAnalyzer', 'Created analysis suggestion memory', {\n      key,\n      sessionId: suggestion.sessionId\n    });\n  }\n\n  /**\n   * Get conversation text for analysis\n   */\n  getConversationForAnalysis(sessionId: string): string {\n    const session = this.sessionManager.getSession(sessionId);\n    if (!session) {\n      return '';\n    }\n\n    const lastAnalyzed = session.lastAnalyzedTurn || 0;\n    return this.sessionManager.getConversationText(sessionId, lastAnalyzed);\n  }\n\n  /**\n   * Mark session as analyzed\n   */\n  markSessionAnalyzed(sessionId: string): void {\n    const session = this.sessionManager.getSession(sessionId);\n    if (session?.conversationHistory) {\n      const turnNumber = session.conversationHistory.length;\n      this.sessionManager.markAnalyzed(sessionId, turnNumber);\n\n      // Note: Analysis suggestion will auto-expire after 1 hour\n      // We could add a delete method to MemoryService in the future\n      // For now, the suggestion will naturally expire\n\n      this.logger.info('PreferenceAnalyzer', 'Session marked as analyzed', {\n        sessionId,\n        turnNumber\n      });\n    }\n  }\n\n  /**\n   * Store extracted preferences from Claude Code's analysis\n   * This is called after Claude analyzes the conversation\n   */\n  async storeExtractedPreferences(\n    preferences: Array<{\n      key: string;\n      value: any;\n      confidence: number;\n      reasoning?: string;\n    }>,\n    sessionId: string\n  ): Promise<void> {\n    this.logger.info('PreferenceAnalyzer', 'Storing extracted preferences', {\n      count: preferences.length,\n      sessionId\n    });\n\n    for (const pref of preferences) {\n      try {\n        await this.memoryService.store({\n          key: pref.key,\n          value: {\n            value: pref.value,\n            confidence: pref.confidence,\n            reasoning: pref.reasoning,\n            source: 'claude-analysis',\n            analyzedAt: Date.now(),\n            sessionId\n          },\n          type: 'preference',\n          context: {\n            sessionId,\n            timestamp: Date.now()\n          }\n        });\n\n        this.logger.debug('PreferenceAnalyzer', 'Stored preference', {\n          key: pref.key,\n          confidence: pref.confidence\n        });\n      } catch (error) {\n        this.logger.error('PreferenceAnalyzer', 'Failed to store preference', error);\n      }\n    }\n\n    // Mark session as analyzed\n    this.markSessionAnalyzed(sessionId);\n  }\n}\n"],"version":3}